{"pages":[{"title":"我是谁？","text":"正如域名所示我是常州刘国钧高等职业技术学校 计算机专业 的一名废材技校生，这是一所江苏境内的五年制高职。正因为自己初中学习不够努力成绩一直处于平均水平以及热爱推广职业教育的常州 40% 多中考录取率，直到最后也没有什么彻底醒悟成绩突飞猛进只有知乎上才能看到的剧情，因此中考考了一个很平均的分数从而很不幸的进入了这一所奇怪的技校，现在即将升入三年级，也就是同龄人的高三。 我的人格是 INTJ ，是一个 十分内向 的人。当得知中考成绩后我释然了，心中毫无波动，但我知道自己的人生完蛋了。我这里中考也没有什么复读的说法，只能无奈的进入了这一所学校。学校的管理措施相比于其他技校似乎更加严格，但依旧无法挽回身边奇怪的同学智力低下的事实。 我可以肯定身边的同学根本不是来学计算机的。经历了一个学期的计算机基础的学习，我们班级较早开始了 C 语言 的课程，可是奇怪的同学依旧连计算机最基础的操作都不会，怎么可能完成编程语言的学习呢？以至于我亲眼看到我的同桌到期中考试连”Hello World”都写不出来，我无奈的笑了。 因为是技校，身边大多数人素质普遍比较低，因此 校园欺凌 是不可避免的。在班上我总能看到弱势的同学遭到强势学生过分的需求，以至于哭泣，甚至有些时候强势的学生当着部分老师的面实施欺凌，老师却能视而不见，悠哉的掏出他的手机，刷着某音，直到上课。正如同前文所说，我是一个十分内向的人，可能代码写的比其他人要好，有时候校园欺凌也会在我的头上发生，但是远不及上文同学的多，我都默默承受了。 emm 可能扯远了吧，技校的奇怪还有很多超乎你想象的，不过我不想再过多举例，下面来聊聊我自己。 “事务对我们都会有影响，其价值必须定量，而非定性地讨论。出去义务扫马路可以陶冶你的情操，还可以锻炼身体。坐在家里背单词背一天你可以学会数百个新单词，提升英语水平。按照上提到的“善意的逻辑”，这两者各有好处，仿佛难以取舍。但是我想在实际操作中，不会有人认为前者对你的益处更大。 说道理大家都清楚，但是在实际生活中，我们却总能见到某些组织的头目派手下同学站在食堂门口发传单，以“锻炼大家的社会实践能力”。我们也能见到不少同学东一榔头西一棒槌地学了许多与自己职业规划毫无关系的课程，美其名曰“扩充知识面”。 在打着各种华丽口号的诱惑面前，我们要保持清醒，并且时刻告诫自己 总有更值得做的事。” 我无法理解奇怪人的脑回路，因此我现在已经离开了班级和宿舍并加入了学校智能家居的集训队，因为是 全国职业院校技能大赛 因此难度十分低，与参加 noi 的 OIer 们完全没法比，可偏偏技校的比赛基本都是 团队型项目，也就代表着我要和奇怪的人一同比赛，我陷入了沉思。。 最后再说说自己的学习情况和对未来的展望吧~其实自己真正开始学习编程是从高职二年级开始的，因为受到了社交平台人们的启发（这个以后再聊），让我认知有很大提升，才开始踏入正轨。 现在已经过去一年了，我逐渐按时间学习了 C, Java, MySQL, SpringBoot, Android 等技术的基础（关于技术的话题以后会经常写的，本文就不展开了），现在正在学习 Android,Kotlin, C++, qt，在接下来的一年内我首先要应对技能比赛（希望队友能给点力 w），然后去学习自己薄弱的英语，多背单词和看英文文章，参加五年级的专转本考试（希望能考上个南京二本学校吧），再去学点高数并在闲暇时间看看Primer C++, CS:APP 和它对应的 15-213 课程 然后完成相应 lab，计算机网络等书，再学学前端 Vue 等技术，有空再做算法题， 再学学 Rust?，可能的话尝试去 github 参加些开源项目。。 补充 上海交通大学生存手册 邮箱: 3100825062@qq.com","link":"/about/index.html"}],"posts":[{"title":"2021 年终总结","text":"冬季 2020 年的后半年我参加了学校智能家居的集训队，学习了些 Android 的皮毛后便进入寒假冬眠生活。 ​ 寒假的前几天我继续学习了些 Android，可能是当初 Java 基础太薄弱了些，对于匿名方法和类的理解还不够透彻，很不幸的我在 RecyclerView 上翻了车，可更糟糕的是我又听从学长的建议购买了一本绝顶的烂书《疯狂 Android 讲义》导致我 Android 直接学蒙了，于是决定先把 Android 搁置下来，去学习了下 MySQL 数据库。 ​ 万幸的是 MySQL 的学习还算顺利，CRUD 写的还算可以，我用尝试用 Hexo 搭建了我的第一个博客，从而逐步对于前端感兴趣起来（虽然当时我根本就分不清前后端 X）。 ​ 接着又利用寒假剩余的时间去学习了下 HTML、CSS，了解了前端开发的基础，糊了下小米商城的首页。学习了 git 的基础用法，尝试把自己的项目推送到 GitHub 上，同时也让我体会到开源社区的美好与自由，希望自己也能在开源社区中贡献出一份力量。 ​ 当然除了 Code 之外，我也过了一个愉快的大年，收到了许多红包，这使我电子产品获得了更新。从原先颗粒感十足的显示器更换成如今的戴尔 U2720QM，使我能够更加舒适的办公和阅读；使用的耳机也换成我梦寐以求的索尼 xm4。 春季​ 度过了寒冷的的冬季后，我从返了校园，回到了自己的厌恶班级和宿舍。班上的同学经历过一个寒假后并没有任何的改变，依旧素质低劣。校园欺凌的施暴者依旧不断骚扰着我，抢我的书包，拿我的文具，上课不断起哄，拍我厕所照片。。。 ​ 我也逐渐习惯了这种感觉，逐渐看淡了这种事情，不再与班上的同学进行往来，下课时间自己默默拿出《第一行代码：Android》来看。下午的“电影”降智时间（技校生会看什么视频也很清楚了），一般会前往集训队独自学习。 ​ 回到宿舍后，室友 A 不是盯着他那抖音不断傻笑，就是玩着他那和平精英骂爹骂娘（其实我也很好奇他是如何做到每局都与野队友开麦互骂的），或者就是翻我柜子，偷我的东西。室友 B 可能忽然领悟，奇迹的学习起了 Python，不过没学习几周，便又沉迷于他电子竞技了。室友 C 与室友 A 相似，总是一唱一和。室友 D 在班上当上了官，总是诉说着与他女友的故事。而我在早已搬家到了床上，带着降噪耳机，进入 coding 模式，不再与任何人来往。 ​ 即便已经习惯了这种生活，但自己内心也不断被折磨着，抑郁的痛苦也总伴随着我的每一天，几乎每天自己都在想“这些人什么时候可以去死啊”、“何时才能停课成为集训队正式成员啊”。。。 ​ 好在功夫不负有心人，在经过多次测试后，我以绝对碾压的优势成功停课，顺利的成为集训队正式成员。 ​ 在集训队中我听从学长的建议，努力攻克了比赛的 C 卷后，才发现这些 Android 题目大同小异。再加上前些时候的努力，我的 Android 水平也终于获得了突破，做题速度大幅提升。 ​ 此时的我如同重获了新生一般，走出了绝望的深渊。因为停课加入了集训队，我获得了大把学习的时间，除了平时写写 Android 以外，还尝试学习了下 JavaScript 和 Linux，操作了 dom 树，完善了之前所写的项目，并部署到了云端。可我当时不知道哪根筋搭错了，根本不知道前后端的区别，又开始学起了 Java Web。 ​ Java Web 的学习花费了我过长的时间，这是我一直很后悔的事。其中刚开始便遇到困难，Maven 环境一直装不上，创建项目一直报错，最后才发现是阿里云镜像仓库地址写错了。而且那是基于 JSP 的 Java Web（现在看起来已经严重落伍了），可我当时并不清楚，而且我的 JDBC 技术又不过关，导致花费了过多的时间在于此处，最后完成了一个超市订单管理系统的项目，现在回想起来真的很不值得。 ​ 另一方面，在我不断的努力下，父母奇迹般的同意给我换电脑，因此我获得了一台发布没多久的幻 16，在此真的很感谢父母。 夏季​ 这是一个难忘夏天，首先因为疫情的原因，我的开学推迟了，从而成为我人生中最漫长的暑假。其次我利用暑假时间掌握了很多技术，完成了我梦寐以求的玩具。 ​ 因为我是集训队正式成员的原因，所以暑假的前半个月选择来学校训练。 ​ 我的学习进度相比较其他梯队成员而言十分超前，因此完成每天的集训任务后我学习起了 SSM 框架，我是从 MyBatis 学起的，MyBatis 的学习过程并没有给我带来太多困难，大约花了 3 天便学完了，整体过程还是比较顺利的。接着又接触了 spring5 和 spring MVC，因为先前我并没有学习过 Java 的注解缘故，这个过程就比较艰辛了，不过功夫不负有心人。我花了半天时间专门去学习了下注解，随后理解起来就轻松很多了，大约花了 8-9 天时间，掌握的基本还行。 ​ 学完 SSM 框架过后，我对自己春季的行为感到惋惜，我花费太长时间在意义不大的 Java Web 上，之前使用琢磨已久的 JDBC 完全可以用 MyBatis 来代替，落后的 JSP 技术那就更不用提了。 ​ 距离我暑假集训还有 4 天，吸取了 Java Web 时的教训，再加上 Spring MVC 的配置过于繁琐和复杂，我决定先不写 SSM 的项目，直接去学习更加方便快捷的 Spring Boot。 ​ Spring Boot 我看的是狂神那套教程（实则讲的很一般，spring boot 学习建议稍微了解一下，直接实战做项目就行），刚开始学习的还好，直到遇见权限管理部分，学习起 spring security 和 Shiro 安全框架时，开始逐渐懵逼起来，在这糊里糊涂之间，4 天的时间逐渐过去了，结束了暑假集训。 ​ 后面我玩了一个礼拜的电脑游戏。 ​ 此时已经是 7 月的下旬，我觉得先把 Spring Boot 放一放，想继续去搞 Android。彼时我遇到了一对矛盾，我的 Android 技术已经完全足够应付比赛了，实则没有继续深入学习下去的意义，当经过我反复琢磨，最终还是出自兴趣考量，决定继续学习下去。 ​ 如果要继续学习 Android 那必然要和 jetpack 以及其 mvvm 架构打起交道，这里我很感谢 longway777 老师在 B 站上的视频，教会了我 ViewModel &amp; LiveData &amp; Room 的使用，以及 mvvm 的架构思想。随后我又跟着 B 站途途 IT 学堂学写了一个视频资讯 APP，而这成为了我 Android 学习的转折点。在这个项目第一次用到了 OkHttp 与后台进行了交互，明白了利用 Token 来保存登录用户信息，清楚了 baseActivity 架构思想，从而为之后的小玩具打下了基础。 ​ 其实在暑假学习 Android 之前，我就想完全独立的开发一款玩具，可是当时水平有限，一直没能实施下去。此时我觉得可以试一试了。 ​ 那么要开发什么类型的玩具呢？在思考很久之后，我发现现在的翻译软件普遍过于花哨，有着很多广告和没有必要的功能。最终我决定开发一款翻译文本的小玩具，从而提供简单而又快捷的翻译需求。 ​ 这是我做过规模最大的玩具，从项目开始一直到结束大约花费了 2 周的时间，代码数量也到达了的 2 万多行。实现了与 Spring Boot 后台进行 JSON 数据交互；在阅读前辈大佬们的玩具时，学习到了 Android Material 组件的使用，使玩具 UI 得以大幅提升；同时也使用到了很多第三方开源的库，让代码简洁很多。。。唯独可惜的是，因为自己能力水平有限，项目中我并没有使用到 jetpack 以及其 mvvm 的架构，这点还是很遗憾的。 ​ 此时我对于 Android 的热情十分火热，明白 Kotlin 和 flutter 是 Android 开发的趋势所向，又跟着《第一行代码 Android 第 3 版》学习了 Kotlin 基本使用，明白了其空安全机制的优势，以及用 Kotlin 编写 Android 免去绑定组件的快捷，还有协程等等。 ​ 只不过我是一个三心二意的人，除了维护之前的 Android 小玩具外，又想起当时在 Spring Boot 上的翻车，很是不甘，因此又重新学习了下这个技术栈，跟着 B 站码神之路大佬学写了一个博客项目后台，从封装返回结果集开始一直到最终 docker 部署，了解一个后台开发大致流程，同时也学习到 MyBatis-Plus、Redis 等技术。 ​ 此时暑假还有半个月左右，我又闲散的学习了 QT 的基础、ES6 语法等。 ​ 另外赶在苹果教育优惠的最后一段时间，还购买了一台 12.9 寸的 ipad Pro； ​ 不过更值得注意的是，父母同意我独自在外面租房子，我终于可以离开那该死的室友了。 秋季​ 伴随着时间的迁移，我的记忆也逐步清晰起来，今年的秋季对我而言十分迅速，眨眼睛就无影无踪了。 ​ 我所参加的智能家居技能大赛是一个团队型的项目，总共需要三名选手共同参赛，一个负责对智能家居进行安装，一个负责用 QT 编写网关，另一个用开发 Android 开发 App。而我是负责移动端软件的。但因为疫情原因，今年秋季开学推迟到了 9 月中旬，我的另外一个 QT 队友还尚未选拔出来。现在总共有 2 名同学来竞争这个职位，分别为 A 同学以及 B 同学。 ​ 不幸的是这两名同学的水平都很一般，A 同学写代码完全靠背，对自己所写的代码完全不理解，写一点基础代码都很吃力；而 B 同学刚与另外一位安装智能家居的 C 同学竞争失利，直接转学 QT，基本没有任何 C++ 基础。最终在经历过多次大大小小的选拔中，留下了 A 同学。 ​ 在此期间我再度抓紧空余时间，写了几个 Spring Boot 小项目，更好的巩固了我的后台基础。另一方面，我又学习了前端 Vue 技术，期间也遇到了不少困难，比如我的 ES6 基础过于薄弱，对于些匿名表达式的理解不够透彻，导致 this 的指向经常烦些错误。并且我的 CSS 遗忘的基本差不多了，连基础的布局都写不对，更别提 Sass、Less 之类的了。不过在经过我的努力之下也逐步克服了这些困难，也能够用 Vue 配合 element ui 写一些简单的后台管理系统了。接着又学习了 Vue3，发现 TypeScript 对我而言学习成本极低，基本就是 Kotlin 和 JavaScript 的结合体，花了 1-2 天时间很快就上手了。我便开始用 Vue 来写一个电商项目，遗憾的是这个项目至今才完成了一小部分。 ​ 此时大约已经是 11 月份了，今年的智能家居项目发生的重大变革，整体难度提升了非常多。除了之前代码部分今年又增加了 CAD、Visio 绘制房屋布线图和 UML 流程图的内容，并且对于安装选手而言还增加许多新器件，这也代表着我和 A 同学代码难度也加大了。实际上这个比赛相当离谱， 先不提增加了毫不相关的设计部分（据说妄想和世界技能大赛靠拢？），主办方企想就是一个诈骗企业，在他那购买的器件基本上都是市场价的 100 倍价格左右，一个 60 块的路由器敢卖你 6000 块，一个 100 块的监控卖你 4 万。。一套器件下来就要 20 多万，每年还以升级器件为由来骗钱，更可笑的是全国购买器件的学校至少有数百支，政府部门竟然无一提出质疑，想必国家大力发展职业教育的钱都花哪去了。 ​ 又过了一个月，企想下发了理论部分的 1000 多道样题，全都是一些过时毫无营养的知识，现在已经是 5G 时代了，所考试的还是 2G 时代的知识，简直够搞笑的。 ​ 大约到了 12 月中旬，学校准备了两次拉练来提高我们水平。第一天是盐城那边的一个学校到这边来，我们进行了模拟比赛，发现盐城那边的综合水平要比我想象中的强很多，而且 3 名选手中有 2 名都是去年参加过比赛的选手，最终以我校失败告终。其实失败的原因也很显然易见，A 同学的代码能力有限，平日里代码只能靠背，一遇到灵活一点的题目就不知所措了，而偏偏这次题目又有很多需要和 A 同学代码进行配合才能实现的功能，虽然我已经尽可能的根据 A 同学的水平只去实现一些简单的功能，但还是高估了其水平，从而导致失利；而另一次拉练是我们前往今年的省赛赛场南京。那所学校比较贫穷，属于乡下学校，但值得讽刺的是，为了承包今年的省赛赛点，光光器件至少花费好几百万，要是这笔钱能够改善下校内学生的生活质量那该多美好呀。南京那边的环境与我们平时训练的还是有些差异的，比如其电脑上所使用的 Android Studio 为 3.0 版本，导致在对数据库操作时出现了“?”占位符编译报错的问题（实则还是可以直接运行的，应该属于 Android Studio3.0 的 bug），拉练一时间比较慌张没想起可以使用拼接 Sql 来替代，而是使用 sp 随便糊了下注册功能，这是值得反思的。 ​ 到了 2022 的一月份比赛正式开始，我也是全力以赴，最终我除了一张折线图以外其他都写出了，但是 A 同学不出所料到最后没来得及烧写 A8，比赛 0 分 了。。。 展望​ 因为 A 同学的原因我们错失了国赛选拔，不过我在集训队中还是学到了很多知识的，希望比赛结束之后能够留在集训室，静下心来学习，远离可怕的班级。 ​ 关于明年的发展，我准备以学习计算机理论和英语为主的，前端为辅，多去阅读些优质书籍，尝试为开源社区做出些微小的贡献。尝试把之前的 CSAPP 给看完，并完成它的课后练习，然后去学习去阅读《计算机网络: 自顶向下方法》配合斯坦福 CS144 完成计算机网络的学习，还有空的话去看看 15445 学下数据库的知识。同时我想尝试去阅读些开源的项目，当然能够提出些 PR 那就很好了。 ​ 在这期间我也要准备好后年专转本的考试，因此英语的重要性是不可小觑的，每天都要坚持背 100 个左右单词，多去看看国外的文章和视频，可能的话可以尝试阅读些原版书籍。 ​ 当然数学的学习也是不可以落下的，不过因为高职的缘故我的数学实在是太糟糕了，从头开始学也是不太现实的。我准备阅读下《程序员的数学》的数学来提升下自己的能力。2​ 总而言之 2021 年对我而言收获还是很充实的，学习到了好多新技术，也交到了些朋友，如果有什么问题也欢迎使用 3100825062@qq.com 与我联系。","link":"/2022/01/09/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%932%E7%89%88/"},{"title":"AndroidV5 包源码解析","text":"今年智能家居安装与维护中职组省赛还有 1 个多月就要开始了，作为一名负责 Android 开发的蒟蒻，来介绍一下刚更新的 SmartHomeV5 包源码吧~ 其实 V5 包的源码并不难理解，结合代码片段的注释是很好理解的，我先给出我所写好的示例 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class MainActivity extends AppCompatActivity { String name,time; double temperature,humidity,illumination; Handler handler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findView(); } private void findView() { // 连接服务器 ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;); SocketClient.getInstance().creatConnect(); SocketClient.getInstance().login(new LoginCallback() { @Override public void onEvent(String var1) { runOnUiThread(new Runnable() { @Override public void run() { if (var1.equals(ConstantUtil.Success)) { Toast.makeText(MainActivity.this, &quot; 连接成功 &quot;, Toast.LENGTH_SHORT).show(); } else if (var1.equals(ConstantUtil.Reconnect)){ Toast.makeText(MainActivity.this, &quot; 重新连接 &quot;, Toast.LENGTH_SHORT).show(); }else { Toast.makeText(MainActivity.this, &quot; 连接失败 &quot;, Toast.LENGTH_SHORT).show(); } } }); } }); new Handler().postDelayed(new Runnable() { @Override public void run() { // 单控 ControlUtils.control(&quot;WarningLight&quot;, &quot;10&quot;, ConstantUtil.CmdCode_1, ConstantUtil.Channel_ALL, ConstantUtil.Open); // 获取数据 ControlUtils.getData(); ControlUtils.getFaceData(); SocketClient.getInstance().getData(new DataCallback&lt;DeviceBean&gt;() { @SuppressLint(&quot;HandlerLeak&quot;) @Override public void onResult(DeviceBean deviceBean) { try { if (!TextUtils.isEmpty(deviceBean.getTime())){ time = deviceBean.getTime(); } } catch (Exception e) { e.printStackTrace(); } try { if (!TextUtils.isEmpty(deviceBean.getName())){ name = deviceBean.getName(); } } catch (Exception e) { e.printStackTrace(); } if (deviceBean.getDevice().size() &gt; 0){ for (int i = 0; i &lt; deviceBean.getDevice().size(); i++) { try { if (deviceBean.getDevice().get(i).getBoardId().equals(&quot;1&quot;)){ if (deviceBean.getDevice().get(i).getSensorType().equals(ConstantUtil.Illumination)){ temperature = Double.parseDouble(deviceBean.getDevice().get(i).getValue()); }else{ humidity = Double.parseDouble(deviceBean.getDevice().get(i).getValue()); } } } catch (NumberFormatException e) { e.printStackTrace(); } try { if (deviceBean.getDevice().get(i).getBoardId().equals(&quot;2&quot;)){ illumination = Double.parseDouble(deviceBean.getDevice().get(i).getValue()); } } catch (NumberFormatException e) { e.printStackTrace(); } } } } }); } },500); }} 连接服务器代码解析 好了话不多说，我们看看连接服务器的代码 1234567891011121314151617181920// 连接服务器ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;);SocketClient.getInstance().creatConnect();SocketClient.getInstance().login(new LoginCallback() { @Override public void onEvent(String var1) { runOnUiThread(new Runnable() { @Override public void run() { if (var1.equals(ConstantUtil.Success)) { Toast.makeText(MainActivity.this, &quot; 连接成功 &quot;, Toast.LENGTH_SHORT).show(); } else if (var1.equals(ConstantUtil.Reconnect)){ Toast.makeText(MainActivity.this, &quot; 重新连接 &quot;, Toast.LENGTH_SHORT).show(); }else { Toast.makeText(MainActivity.this, &quot; 连接失败 &quot;, Toast.LENGTH_SHORT).show(); } } }); }}); 别看这只有几行代码，其实已经执行完 V5 包里几乎全部的代码了 creatConnect()方法 单例模式的运用 我们进入登录的 SocketClient.getInstance().creatConnect(); 的里面，这里涉及到一个单例模式，实例化唯一的 SocketClient 对象。 1234567// 我们调用 SocketClient.getInstance().XXXX()的时候这个方法都会被调用，也就是单例模式，用来实例化唯一的 SocketClient 对象 public static SocketClient getInstance() { if (null == mInstance) { mInstance = new SocketClient(); } return mInstance; } 启动 InitSocketThread 线程 接着我们看到如下，请仔细观看注释 ， 注意：通过源码我们可以看出，我们写代码每执行 SocketClient.getInstance().creatConnect() 就会断开一下与服务器的连接，因此请不要把这句话放在 Fragment 里或者多次执行 123456789101112131415// 如果之前已经连接过服务器，再次调用 creatConnect()会断开现有连接再重新连接服务器，因此 creatConnect()要谨慎调用 public boolean creatConnect() { // 第一次创建则为空，因此会执行 InitSocketThread() 的线程 if (this.mSocket == null) { // 开启连接服务器线程 (new SocketClient.InitSocketThread()).start(); } else { // 用来断开与服务器连接。 this.release(); // 开启连接服务器线程 (new SocketClient.InitSocketThread()).start(); } return false;} 我们假设初次调用 creatConnect() 方法，便会开启 (new SocketClient.InitSocketThread()).start() 线程， 如下我们进入这个线程，这个线程意义不大，直接调用了 SocketClient.this.initSocket() 方法 12345678910// 执行 initSocket()方法用的class InitSocketThread extends Thread { InitSocketThread() { } public void run() { super.run(); SocketClient.this.initSocket(); }} V5 包核心 initSocket()方法 如下我们进入 SocketClient.this.initSocket() 方法，这是整个 V5 包的核心代码，请 仔细仔细再仔细阅读注释 12345678910111213141516171819202122232425262728293031//V5 源码的核心方法！！！！private void initSocket() { try { // 创建并实例化 socket Socket socket = new Socket(); // 连接服务器，ip 为我们之前 &quot;ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;);&quot; 中的 &quot;127.0.0.1&quot;，端口号是定死的 (6006) 无法更改 socket.connect(new InetSocketAddress(ip, this.port), 3000); // 把已经连接服务器的 socket 赋值给全局的 mSocket。这里的 mSocket 和 Socket 是弱引用，不严谨的说可以直接理解为创建 Socket 实例对象 this.mSocket = new WeakReference(socket); // 把我们的之前 &quot;ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;);&quot; 中的 &quot;bizideal&quot;, &quot;123456&quot; 发送给服务器，可以去看 sendData() ControlUtils.getData(); // 实例化 ReadThread 对象，ReadThread 的线程是用来获取服务器数据的 this.mReadThread = new SocketClient.ReadThread((Socket)this.mSocket.get()); // 启动实例化 ReadThread 线程，获取服务器数据的 this.mReadThread.start(); // 执行心跳包，检测是否掉线 this.mHandler.postDelayed(this.heartBeatRunnable, 10000L); // 成功连接服务器则都不为空 if (this.mSocket != null &amp;&amp; this.mLoginCallback != null) { // 根据 ConstantUtil, 会 Toast 连接成功 this.mLoginCallback.onEvent(&quot;0&quot;); } } catch (IOException var2) { if (this.mLoginCallback != null) { // 根据 ConstantUtil, 会 Toast 连接失败, 无法连接服务器 this.mLoginCallback.onEvent(&quot;1&quot;); } // 断开服务器连接 this.disConnect(this.mSocket); }} 上面代码可能比较难理解，不过我们可以把它拆分成 3 部分 ControlUtils.getData();请求数据 this.mReadThread = new SocketClient.ReadThread((Socket)this.mSocket.get());this.mReadThread.start();接收数据 this.mHandler.postDelayed(this.heartBeatRunnable, 10000L);心跳包检测连接服务器状态 请求数据 进入 ControlUtils.getData() 里，这里比较简单，就是发送 JSON 请求给服务器，表明需要得到数据 123456789101112131415// 数据采集public static boolean getData() { try { JSONObject object = new JSONObject(); object.put(&quot;Type&quot;, &quot;GetDevicState&quot;); object.put(&quot;UserName&quot;, mUserName); object.put(&quot;Password&quot;, mPassword); object.put(&quot;CurrentTime&quot;, (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)).format(new Date())); // 把 JSON 请求发送给服务器 SocketClient.getInstance().sendData(object.toString()); } catch (JSONException var1) { var1.printStackTrace(); } return true;} 接着进入 SocketClient.getInstance().sendData(object.toString()); 仔细观看注释，发送数据给服务器其中 msg 是刚刚在 ControlUtils 中创建的 JSON 数据，最终会将这个数据发送给服务器。另外注意 SocketClient.this.sendTime = System.currentTimeMillis() 获取发送数据的时间，在第三部分心跳包检测会用的。OK 非常简单，第一部分发送数据就是这个流程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 发送数据给服务器其中 msg 是在 ControlUtils 中创建的 JSON 数据，这里的 boolean 返回值后续会用做“心跳包“检测 public boolean sendData(final String msg) { // 老规矩检查你是否连接了服务器 if (null != this.mSocket &amp;&amp; null != this.mSocket.get()) { // 把全局 mSocket 赋值给局部的 soc final Socket soc = (Socket)this.mSocket.get(); try { // 老规矩检查你是否连接了服务器 if (!soc.isClosed() &amp;&amp; !soc.isOutputShutdown()) { // 用流来发送数据，不过多解释 (new Thread(new Runnable() { public void run() { try { // 用流来发送数据，不过多解释 PrintWriter DataWrite = new PrintWriter(soc.getOutputStream()); DataWrite.write(msg + &quot;\\r\\n&quot;); DataWrite.flush(); //isSocket 是用来判断是否发送成功的 SocketClient.this.isSocket = true; //sendTime 获取发送数据的时间，会在另一个线程使用到，判断连接状态 SocketClient.this.sendTime = System.currentTimeMillis(); } catch (IOException var2) { var2.printStackTrace(); //isSocket 是用来判断是否发送成功的 SocketClient.this.isSocket = false; } } })).start(); } else { //isSocket 是用来判断是否发送成功的 this.isSocket = false; } } catch (Exception var4) { var4.printStackTrace(); //isSocket 是用来判断是否发送成功的 this.isSocket = false; } //isSocket 是用来判断是否发送成功的 return this.isSocket; } else { return false; } } 接收数据 我们回到 V5 包的核心 initSocket 方法，看到如下代码，其中 ReadThread 就是用来接收数据的 1234// 实例化 ReadThread 对象，ReadThread 的线程是用来获取服务器数据的this.mReadThread = new SocketClient.ReadThread((Socket)this.mSocket.get());// 启动实例化 ReadThread 线程，获取服务器数据的this.mReadThread.start(); 进入上方 ReadThread 这个线程，仔细观看注释，这个线程往往使用来响应刚才的请求数据，用来读取服务器发送给我们的数据，会得到一串 服务器响应给我们的 JSON 数据 ，最后交给SocketClient.this.setData(obj) 解析，最终赋值到 DeviceBean 这个类中，供我们直接使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 获取服务器数据 private class ReadThread extends Thread { // 弱引用局部 Socket private WeakReference&lt;Socket&gt; mWeakSocket; private boolean isStart = true; public ReadThread(Socket socket) { // 转移全局 Socket this.mWeakSocket = new WeakReference(socket); } // 断开服务器连接 public void release() { this.isStart = false; // 断开服务器连接 SocketClient.this.disConnect(this.mWeakSocket); } // 获取服务器数据 public void run() { super.run(); // 梅开 n 度, 把局部的 mWeakSocket 转移给线程内的 socket Socket socket = (Socket)this.mWeakSocket.get(); // 判空 if (socket != null) { try { String response = &quot;&quot;; // 读取服务器数据 BufferedReader DataRead = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 判空 while(!socket.isClosed() &amp;&amp; this.isStart &amp;&amp; !socket.isInputShutdown()) { // 判空 while((response = DataRead.readLine()) != null) { // 获取服务器返回的 JSON 数据 JSONObject obj = new JSONObject(response); // 解析服务器 JSON 数据 SocketClient.this.setData(obj); } } } catch (JSONException var5) { var5.printStackTrace(); } catch (Exception var6) { // 未知异常就断开服务器连接 this.isStart = false; SocketClient.this.mSocket = null; var6.printStackTrace(); } } } } 下方是 SocketClient.this.setData(obj) 解析我们收到的 JSON 数据，解析完成后，也就是我们 MainActivity 最终调用 SocketClient.getInstance().getData() 的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 解析服务器返回的 JSON 数据public void setData(JSONObject obj) throws JSONException { DeviceBean bean = new DeviceBean(); if (obj.has(&quot;Type&quot;)) { // 判断数据是数据采集还是考勤机或心跳包的 if (!obj.getString(&quot;Type&quot;).toString().equals(&quot;Upload&quot;) &amp;&amp; !obj.getString(&quot;Type&quot;).toString().equals(&quot;GetDevicState&quot;)) { // 判断是否为考勤机 if (obj.getString(&quot;Type&quot;).toString().equals(&quot;UploadPersonInfo&quot;) || obj.getString(&quot;Type&quot;).toString().equals(&quot;GetCurrentAttendance&quot;)) { try { if (obj.has(&quot;Name&quot;)) { // 考勤的姓名 DeviceBean.setName(obj.getString(&quot;Name&quot;)); } } catch (JSONException var9) { } try { if (obj.has(&quot;Time&quot;)) { // 考勤的日期 DeviceBean.setTime(obj.getString(&quot;Time&quot;)); } } catch (JSONException var8) { } if (mDataCallback != null) { mDataCallback.onResult(bean); } } } else { // 这里是数据采集的 JSON 解析 try { // 具体怎么解析 JSON 就不说明了 ArrayList&lt;Devices&gt; deviceList = new ArrayList(); JSONArray array = new JSONArray(obj.get(&quot;Data&quot;).toString()); for(int i = 0; i &lt; array.length(); ++i) { JSONObject jsonObject = array.getJSONObject(i); Devices devices = new Devices(); // 数据的值 devices.setValue(jsonObject.getString(&quot;Value&quot;)); // 类型 devices.setSensorType(jsonObject.getString(&quot;SensorType&quot;)); // 版号 devices.setBoardId(jsonObject.getString(&quot;BoardId&quot;)); deviceList.add(devices); } // 解析完的数据放进 DeviceBean 集合中 DeviceBean.setDevice(deviceList); } catch (JSONException var10) { } // 如果写了获取数据的回调，就执行可以拿到数据了 if (mDataCallback != null) { mDataCallback.onResult(bean); } } } else if (obj.has(&quot;state&quot;) &amp;&amp; obj.getString(&quot;state&quot;).toString().equals(&quot;Failure&quot;) &amp;&amp; obj.has(&quot;msg&quot;) &amp;&amp; this.mLoginCallback != null) { // 未知错误 this.mLoginCallback.onEvent(&quot;5&quot;); }} 心跳包检测 我们回到 V5 包的核心 initSocket 方法，看到如下代码，这里开启 heartBeatRunnable 用于心跳包检测，当你超过 10 秒钟没有发送数据给服务器便会执行，应用服务器心跳检测，简称“心跳包”，检测你是否掉线，其中 SocketClient.this.sendTime 就是第一部分，请求数据接收的时间 12// 执行心跳包，检测是否掉线this.mHandler.postDelayed(this.heartBeatRunnable, 10000L); 12345678910111213141516171819202122232425262728293031323334// 用来开启下方 heartBeatRunnable 线程，详情看 initSocket()方法 private Handler mHandler = new Handler();// 配合上方 mHandler 开启线程 详情看 initSocket() 方法// 判断你是否掉线private Runnable heartBeatRunnable = new Runnable() { public void run() { try { // 当你超过 10 秒钟没有发送数据给服务器变会执行，应用服务器心跳检测，简称“心跳包”，检测你是否掉线，SocketClient.this.sendTime 就是第一部分，请求数据接收的时间 if (System.currentTimeMillis() - SocketClient.this.sendTime &gt;= 10000L) { // 发送心跳包 boolean isSuccess = SocketClient.this.sendData(&quot;{\\&quot;Type\\&quot;: \\&quot;HeartBeat\\&quot;}&quot;); // 如果掉线 if (!isSuccess) { // 如果你调用了 LoginCallback 回调，就!=null if (SocketClient.this.mLoginCallback != null) { // 根据 ConstantUtil 的 public static String Reconnect = &quot;2&quot;; 会 Toast 出“重新连接 &quot; SocketClient.this.mLoginCallback.onEvent(&quot;2&quot;); } // 停止这个 heartBeatRunnable 线程 SocketClient.this.mHandler.removeCallbacks(SocketClient.this.heartBeatRunnable); // 断开服务器连接 SocketClient.this.mReadThread.release(); // 重新建立服务器连接 (SocketClient.this.new InitSocketThread()).start(); } } // 以每 15 秒频率重复执行心跳包 SocketClient.this.mHandler.postDelayed(this, 15000L); } catch (Exception var2) { var2.printStackTrace(); } }}; 总结 &amp;&amp; 源码 以上便是 V5 包源码的全部核心，剩下一部分没有提到的都很好理解，相信可以做到举一反三吧 emmmmm，如果有什么不明白的可以发送邮件到 1502972236zwj@gmail.com 与我联系，最后附上全部SocketClien 类的源码注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363package com.bizideal.smarthome.socket;import android.os.Handler;import com.bizideal.smarthome.socket.DeviceBean.Devices;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.lang.ref.WeakReference;import java.net.InetSocketAddress;import java.net.Socket;import java.util.ArrayList;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;//V5 连接服务器核心类 public class SocketClient { //SocketClient(也就是自己) 的实例对象 private static SocketClient mInstance; // 获取数据回调 private static DataCallback mDataCallback; // 创建全局 Socket 的弱引用，不严谨的说可以直接理解为创建 Socket 实例对象 private WeakReference&lt;Socket&gt; mSocket; // 创建 ReadThread 对象，ReadThread 的线程是用来获取服务器数据的 public SocketClient.ReadThread mReadThread; // 每次向服务器发送数据的时间, 详情看 sendData() 方法 private long sendTime = 0L; //ip 在 ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;); 会对其赋值 public static String ip = &quot;10.1.3.173&quot;; // 定死的服务器断开号，无法更改 int port = 6006; // 登录回调 private LoginCallback mLoginCallback; // 没用 private Boolean isSuccess = false; // 用来开启下方 heartBeatRunnable 线程，详情看 initSocket() 方法 private Handler mHandler = new Handler(); // 配合上方 mHandler 开启线程 详情看 initSocket() 方法 // 判断你是否掉线 private Runnable heartBeatRunnable = new Runnable() { public void run() { try { // 当你超过 10 秒钟没有发送数据给服务器便会执行，应用服务器心跳检测，简称“心跳包”，检测你是否掉线， if (System.currentTimeMillis() - SocketClient.this.sendTime &gt;= 10000L) { // 发送心跳包 boolean isSuccess = SocketClient.this.sendData(&quot;{\\&quot;Type\\&quot;: \\&quot;HeartBeat\\&quot;}&quot;); // 如果掉线 if (!isSuccess) { // 如果你调用了 LoginCallback 回调，就!=null if (SocketClient.this.mLoginCallback != null) { // 根据 ConstantUtil 的 public static String Reconnect = &quot;2&quot;; 会 Toast 出“重新连接 &quot; SocketClient.this.mLoginCallback.onEvent(&quot;2&quot;); } // 停止这个 heartBeatRunnable 线程 SocketClient.this.mHandler.removeCallbacks(SocketClient.this.heartBeatRunnable); // 断开服务器连接 SocketClient.this.mReadThread.release(); // 重新建立服务器连接 (SocketClient.this.new InitSocketThread()).start(); } } // 以每 15 秒频率重复执行心跳包 SocketClient.this.mHandler.postDelayed(this, 15000L); } catch (Exception var2) { var2.printStackTrace(); } } }; // 这是一个 flag 用来判断是否成功发送数据给服务器 private boolean isSocket = false; public SocketClient() { } // 我们调用 SocketClient.getInstance().XXXX() 的时候这个方法都会被调用，也就是单例模式，用来实例化唯一的 SocketClient 对象 public static SocketClient getInstance() { if (null == mInstance) { mInstance = new SocketClient(); } return mInstance; } public boolean creatConnect() { // 第一次创建则为空，因此会执行 InitSocketThread() 的线程 if (this.mSocket == null) { // 开启连接服务器线程 (new SocketClient.InitSocketThread()).start(); } else { // 如果之前已经连接过服务器，再次调用 creatConnect() 会断开现有连接再重新连接服务器，因此 creatConnect()要谨慎调用 this.release(); // 开启连接服务器线程 (new SocketClient.InitSocketThread()).start(); } return false; } //V5 源码的核心方法！！！！ private void initSocket() { try { // 创建并实例化 socket Socket socket = new Socket(); // 连接服务器，ip 为我们之前 &quot;ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;);&quot; 中的 &quot;127.0.0.1&quot;，端口号是定死的(6006) 无法更改 socket.connect(new InetSocketAddress(ip, this.port), 3000); // 把已经连接服务器的 socket 赋值给全局的 mSocket this.mSocket = new WeakReference(socket); // 把我们的之前 &quot;ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;);&quot; 中的 &quot;bizideal&quot;, &quot;123456&quot; 发送给服务器，可以去看 sendData() ControlUtils.getData(); // 实例化 ReadThread 对象，ReadThread 的线程是用来获取服务器数据的 this.mReadThread = new SocketClient.ReadThread((Socket)this.mSocket.get()); // 启动实例化 ReadThread 线程，获取服务器数据的 this.mReadThread.start(); // 执行心跳包，检测是否掉线 this.mHandler.postDelayed(this.heartBeatRunnable, 10000L); // 成功连接服务器则都不为空 if (this.mSocket != null &amp;&amp; this.mLoginCallback != null) { // 根据 ConstantUtil, 会 Toast 连接成功 this.mLoginCallback.onEvent(&quot;0&quot;); } } catch (IOException var2) { if (this.mLoginCallback != null) { // 根据 ConstantUtil, 会 Toast 连接失败, 无法连接服务器 this.mLoginCallback.onEvent(&quot;1&quot;); } // 断开服务器连接 this.disConnect(this.mSocket); } } // 发送数据给服务器其中 msg 是在 ControlUtils 中创建的 JSON 数据，这里的 boolean 返回值后续会用做“心跳包“检测 public boolean sendData(final String msg) { // 老规矩检查你是否连接了服务器 if (null != this.mSocket &amp;&amp; null != this.mSocket.get()) { // 把全局 mSocket 赋值给局部的 soc final Socket soc = (Socket)this.mSocket.get(); try { // 老规矩检查你是否连接了服务器 if (!soc.isClosed() &amp;&amp; !soc.isOutputShutdown()) { // 用流来发送数据，不过多解释 (new Thread(new Runnable() { public void run() { try { // 用流来发送数据，不过多解释 PrintWriter DataWrite = new PrintWriter(soc.getOutputStream()); DataWrite.write(msg + &quot;\\r\\n&quot;); DataWrite.flush(); //isSocket 是用来判断是否发送成功的 SocketClient.this.isSocket = true; //sendTime 获取发送数据的时间，会在另一个线程使用到，判断连接状态 SocketClient.this.sendTime = System.currentTimeMillis(); } catch (IOException var2) { var2.printStackTrace(); //isSocket 是用来判断是否发送成功的 SocketClient.this.isSocket = false; } } })).start(); } else { //isSocket 是用来判断是否发送成功的 this.isSocket = false; } } catch (Exception var4) { var4.printStackTrace(); //isSocket 是用来判断是否发送成功的 this.isSocket = false; } //isSocket 是用来判断是否发送成功的 return this.isSocket; } else { return false; } } // 解析服务器返回的 JSON 数据 public void setData(JSONObject obj) throws JSONException { DeviceBean bean = new DeviceBean(); if (obj.has(&quot;Type&quot;)) { // 判断数据是数据采集还是考勤机或心跳包的 if (!obj.getString(&quot;Type&quot;).toString().equals(&quot;Upload&quot;) &amp;&amp; !obj.getString(&quot;Type&quot;).toString().equals(&quot;GetDevicState&quot;)) { // 判断是否为考勤机 if (obj.getString(&quot;Type&quot;).toString().equals(&quot;UploadPersonInfo&quot;) || obj.getString(&quot;Type&quot;).toString().equals(&quot;GetCurrentAttendance&quot;)) { try { if (obj.has(&quot;Name&quot;)) { // 考勤的姓名 DeviceBean.setName(obj.getString(&quot;Name&quot;)); } } catch (JSONException var9) { } try { if (obj.has(&quot;Time&quot;)) { // 考勤的日期 DeviceBean.setTime(obj.getString(&quot;Time&quot;)); } } catch (JSONException var8) { } if (mDataCallback != null) { mDataCallback.onResult(bean); } } } else { // 这里是数据采集的 JSON 解析 try { // 具体怎么解析 JSON 就不说明了 ArrayList&lt;Devices&gt; deviceList = new ArrayList(); JSONArray array = new JSONArray(obj.get(&quot;Data&quot;).toString()); for(int i = 0; i &lt; array.length(); ++i) { JSONObject jsonObject = array.getJSONObject(i); Devices devices = new Devices(); // 数据的值 devices.setValue(jsonObject.getString(&quot;Value&quot;)); // 类型 devices.setSensorType(jsonObject.getString(&quot;SensorType&quot;)); // 版号 devices.setBoardId(jsonObject.getString(&quot;BoardId&quot;)); deviceList.add(devices); } // 解析完的数据放进 DeviceBean 集合中 DeviceBean.setDevice(deviceList); } catch (JSONException var10) { } // 如果写了获取数据的回调，就执行可以拿到数据了 if (mDataCallback != null) { mDataCallback.onResult(bean); } } } else if (obj.has(&quot;state&quot;) &amp;&amp; obj.getString(&quot;state&quot;).toString().equals(&quot;Failure&quot;) &amp;&amp; obj.has(&quot;msg&quot;) &amp;&amp; this.mLoginCallback != null) { // 未知错误 this.mLoginCallback.onEvent(&quot;5&quot;); } } // 断开服务器连接 public void disConnect(WeakReference&lt;Socket&gt; mSocket) { try { if (mSocket != null) { Socket sk = (Socket)mSocket.get(); if (!sk.isClosed()) { sk.close(); } sk = null; mSocket = null; } } catch (IOException var3) { var3.printStackTrace(); } } // 断开服务器连接 public void release() { try { if (mInstance != null) { mInstance = null; } if (this.mReadThread != null) { this.mReadThread.release(); } if (this.mHandler != null) { this.mHandler.removeCallbacks(this.heartBeatRunnable); } } catch (Exception var2) { } } // 连接服务器的 LoginCallback 赋值给全局 mLoginCallback public void login(LoginCallback callback) { this.mLoginCallback = callback; } public void getData(DataCallback callback) { mDataCallback = callback; } // 获取服务器数据 private class ReadThread extends Thread { // 局部 Socket private WeakReference&lt;Socket&gt; mWeakSocket; private boolean isStart = true; public ReadThread(Socket socket) { // 转移全局 Socket this.mWeakSocket = new WeakReference(socket); } // 断开服务器连接 public void release() { this.isStart = false; // 断开服务器连接 SocketClient.this.disConnect(this.mWeakSocket); } // 获取服务器数据 public void run() { super.run(); // 梅开 n 度, 把局部的 mWeakSocket 转移给线程内的 socket Socket socket = (Socket)this.mWeakSocket.get(); // 判空 if (socket != null) { try { String response = &quot;&quot;; // 读取服务器数据 BufferedReader DataRead = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 判空 while(!socket.isClosed() &amp;&amp; this.isStart &amp;&amp; !socket.isInputShutdown()) { // 判空 while((response = DataRead.readLine()) != null) { // 获取服务器返回的 JSON 数据 JSONObject obj = new JSONObject(response); // 解析服务器 JSON 数据 SocketClient.this.setData(obj); } } } catch (JSONException var5) { var5.printStackTrace(); } catch (Exception var6) { // 未知异常就断开服务器连接 this.isStart = false; SocketClient.this.mSocket = null; var6.printStackTrace(); } } } } // 执行 initSocket() 方法用的 class InitSocketThread extends Thread { InitSocketThread() { } public void run() { super.run(); SocketClient.this.initSocket(); } }}","link":"/2021/11/06/AndroidV5%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"『Kotlin 教程 (1)』 变量、逻辑控制语句、类与空安全机制","text":"大家好我又来更新博客啦，最近自己正在学习用 Kotlin 来编写 Android，决定写篇博客来巩固自身 Kotlin 语法。本博客尽可能采用 Kotlin 与 Java 互相对照方式来呈现，因此需要读者有一定的 Java 基础。 有关 Kotlin 的发展历史和环境搭建之类的请自行搜寻，毕竟大家也有一定的编程基础，就不再介绍了。 Kotlin 的基本数值类型包括Int、Long、Short、Float、Double、Boolean、Char、Byte 等，用法上与 Java 没有区别，但请仔细观察他们的大小写，避免不必要的错误。 变量Kotlin 的变量分为可变变量（var）和不可变变量(val) 12345678// 对应的 Kotlin 代码如下var &lt; 标识符 &gt; : &lt; 类型 &gt; = &lt; 初始化值 &gt; // 可变变量var a : Int = 1 // 为可变变量整型 a 赋值为 1val &lt; 标识符 &gt; : &lt; 类型 &gt; = &lt; 初始化值 &gt; // 不可变变量val b: Int = 1 // 为不可变变量整型 a 赋值为 1print(&quot;a 的大小为 -&gt;$a&quot;) // 输出 a 123456// 对应的 Java 代码如下int a = 1;final int b = 1； System.out.println(&quot;a 的大小为 -&gt;&quot; + a); 在我们编写代码中一般优先考虑val（不可变变量） 从上述代码可以很明显的发现 Kotlin 是 先写标识符后写类型的，这点可能会不太习惯，需要多加练习 $ 符号表示引用的意思。这里理解为 字符串模板，可快捷的对变量进行操作 每一行代码的结束可以省略掉分号 ; 第一次写可能会有一点不习惯。 编译器支持自动类型判断, 即声明时可以 不指定类型, 由编译器判断，因此上述代码可改为如下，我们应该尽可能的采用这种方式赋值 123var a = 1 // 为可变变量整形 a 赋值为 1val a = 1 // 为不可变变量整形 a 赋值为 1 for 循环 Kotlin 废除了 Java 中的 for(初始值; 条件; 增减步长) 这个规则。但是 Kotlin 中对于 for 循环语句新增了其他的规则，来满足我们的需求 123456789101112131415for(i in 0 until 3){ print(&quot;$i &quot;) // 输出 0 1 2 即为[n,m) 大于等于 n, 小于 m}for (i in 3 downTo 0){ print(&quot;$i &quot;) // 输出 3 2 1 0 即为[n,m] 小于等于 n, 大于等于 m ,n &gt; m}for (i in 0..3){ print(&quot;$i &quot;) // 输出 0 1 2 3 即为[n,m] 大于等于 n，小于等于 m}for (i in 0..3 step 2){ print(&quot;$i &quot;) // 输出 0 2 即设置步长为 2} 12345678910111213141516// 对应的 Java 代码for (int i = 0; i &lt; 3; i++) { System.out.print(i + &quot; &quot;);}for (int i = 3; i &gt;= 0 ; i--) { System.out.print(i + &quot; &quot;);}for (int i = 0; i &lt;= 3; i++) { System.out.print(i + &quot; &quot;);}for (int i = 0; i &lt;= 3; i=i+2) { System.out.print(i + &quot; &quot;);} 这里不再过多叙述，请仔细揣摩 When 语句 在 Kotlin 中废除了 Java 的 switch 语句，改为 When 语句，When 语句非常强大，还可以替代 if else() 语句 12345678when(3){ 1 -&gt; print(&quot;1&quot;) 2 -&gt; print(&quot;2&quot;) else -&gt;{ print(&quot;3&quot;) }}// 最终输出 3 1234567891011// 对应 java 代码switch (3){ case 1: System.out.print(&quot;1&quot;); break; case 2: System.out.print(&quot;2&quot;); break; default: System.out.print(&quot;3&quot;);} 这里只做简单介绍，请自己多加摸索 类的使用以及声明可空变量 Kotlin 和 Java 一样也有类和方法，但在 Kotlin 中我们一般把方法称之为 函数，类和函数的定义如下 12345678910111213141516class a { // 类名为 a private val age = 15 private lateinit var name: String // 声明一个变量并延迟初始化 private var hobby: String? = null // 要给变量赋值为 null 或 0 时，需要在类型后加？ // private val num2 会报错，Kotlin 在类中的基本数值类型必须初始化且无法使用 lateinit 延迟初始化 fun say() { // num = 17 报错，因为声明的是 val 所以不能修改 name = &quot; 张三 &quot; print(&quot; 我叫$name，今年${age} 岁了 &quot;) } // 成员函数}fun main() { val b:a = a() // 实例化 b.say() // 调用函数 sum 输出: 我叫张三，今年 15 岁了} 12345678910111213141516// 对应的 Java 代码class a{ private final int age = 15; private String name; private String hobby = null; void say(){ name = &quot; 张三 &quot;; System.out.println(&quot; 我叫 &quot; + name + &quot;, 今年 &quot; + age + &quot; 岁了 &quot;); } public static void main(String[] args) { final a b = new b(); b.say(); }} Kotlin 没有 new 关键字 由于 Kotlin 的空安全机制，可以有效防止程序出现空指针异常，因此需要进行额外的处理 创建成员对象必须初始化，如果不初始化，需使用 lateinit 关键字 基本数值类型无法使用 lateinit 关键字，必须赋值 要给变量赋值为 null 或 0 时，需要在类型后加?","link":"/2021/08/19/Kotlin%E5%AD%A6%E4%B9%A0-1/"},{"title":"『Kotlin 教程 (2)』 构造器、继承、接口","text":"这里是 Kotlin 基础教程的第二篇，本篇会简单快速的介绍 Kotlin 面向对象的几个重点。因博主自身也是个菜鸡，博文可能会出现错误，还请多多指教。另外本博客尽可能采用 Kotlin 与 Java 互相对照方式来呈现，因此需要读者有一定的 Java 基础。 构造器 Kotlin 的构造器写法与 Java 有些不同。在 Kotlin 中，允许有一个主构造函数和多个二级构造函数（辅助构造函数），其中主构造函数是类头的一部分。构造器一般用关键字constructor 表示，请仔细看下面例子 123456789101112131415class Test constructor(num1:Int) { // constructor 也可以省略 即 class a (num1:Int) { init { println(&quot;num1 = $num1&quot;) // 使用 init 可以对主构造器里值进行操作 } constructor(num1: Int,num2 : Int):this(num1){ // 这是二级构造，也就是 java 中的构造器重载 println(num1 + num2) }}fun main() { val test1:Test = Test(1) // 调用主构造实例化对象 val test2:Test = Test(1,2) // 调用主构造和二级构造实例化对象} 12345678910111213141516171819202122// 对应 Java 代码，未必完全对应，但思路一致public class Test { private int num1; private int num2; public Test(int num1){ this.num1 = num1; System.out.println(&quot;num1 = &quot; + num1); } public Test(int num1,int num2){ this(num1); this.num2 = num2; System.out.println(num1+num2); } public static void main(String[] args) { Test test1 = new Test(1); Test test2 = new Test(1,2); }} 结果输出 num1 = 1num1 = 13 请仔细对比观察，应当很好理解，对应 java 代码仅供参考，并非完全一致 Kotlin 实例化对象没有 new 关键字 主构造的 constructor 可以省略 构造器也可以赋初值class Test constructor(num1:Int = 1) {} ，但用的不多，如需了解请自行查阅资料 关于 get 和 set 方法，kotlin 自动生成，无需主动去写，想要详细了解请自行查阅资料 继承 Kotlin 继承写法与 Java 也有少些不同，定义继承类需要额外使用关键字 open。不管是类、还是成员都需要使用open 关键字。定义格式如下 1234567open class 类名{ open var/val 属性名 = 属性值 open fun 函数名() } 请看下面例子 123456789101112131415161718192021222324252627282930open class Person(name:String) {// 必须使用 open 关键字这个类才能被继承！这里是省略 constructor 关键字的主构造 constructor(name:String,age:Int):this(name){// 函数重载 println(&quot; 父类构造完成创建 &quot;) } open fun study(){ // 使用 open 关键字允许子类重写 println(&quot; 我上高中了 &quot;) }}class Student(name: String, age: Int,id:String,score:Int) : Person(name, age){//Student 类继承 Person 类。Person(name, age) 这里类似于 Java 的 super init { println(&quot; 子类构造完成创建 &quot;) println(&quot;name = $name&quot;) println(&quot;age = $age&quot;) println(&quot;id = $id&quot;) println(&quot;score = $score&quot;) } override fun study() { println(&quot; 我上技校了 &quot;) // 子类重写 study 方法 }}fun main() { val goodStudent:Person = Person(&quot; 张三 &quot;,17) // 实例化父类 goodStudent.study() // 调用父类 study 方法 println() val badStudent:Student = Student(&quot;Suemor&quot;,17,&quot;sb123&quot;,80) // 实例化子类 badStudent.study() // 调用子类重写父类的 study 方法} 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 对应 Java 代码，未必完全对应，但思路一致public class Person { private String name; private int age; public Person(String name){ this.name = name; } public Person(String name,int age){ this(name); this.age = age; System.out.println(&quot; 父类二级构造完成创建 &quot;); } public void study(){ System.out.println(&quot; 我上高中了 &quot;); }}class Student extends Person{ private String id; private int score; public Student(String name, int age,String id,int score) { super(name, age); this.id = id; this.score = score; System.out.println(&quot; 子类构造完成创建 &quot;); System.out.println(&quot;name = &quot; + name); System.out.println(&quot;age = &quot; + age); System.out.println(&quot;id = &quot; + id); System.out.println(&quot;score = &quot; + score); } @Override public void study() { System.out.println(&quot; 我上技校了 &quot;); } public static void main(String[] args) { Person goodStudent = new Person(&quot; 张三 &quot;, 17); goodStudent.study(); System.out.println(); Student badStudent = new Student(&quot;Suemor&quot;, 17, &quot;sb123&quot;, 80); badStudent.study(); }} 最终输出 父类构造完成创建 我上高中了 父类构造完成创建 子类构造完成创建 name = Suemorage = 17id = sb123score = 80 我上技校了 继承思路基本与 Java 相同，一定要仔细看例子并与 Java 代码对比，一定可以理解的 w 接口 接口定义关键字：interface，格式如下 123interface 接口名{ ...} 接口的实现，格式如下 1234class 类名 ： 接口名{ // 重写的接口函数、属性等 ...} 请看示例 1234567891011121314interface Person{ // 使用 interface 定义接口 fun name()}class Student : Person { // 使用: 来实现接口, 类似于 Java 的 implements 关键字 override fun name() { // 实现方法 println(&quot; 我的名字是 Suemor&quot;) }}fun main() { val student:Student = Student() // 实例化 Student student.name() // 调用实现的 name 方法} 123456789101112131415// 对应的 Java 代码interface Person { public void name();}class Student implements Person{ @Override public void name() { System.out.println(&quot; 我的名字是 Suemor&quot;); } public static void main(String[] args) { Student student = new Student(); student.name(); }} 最终输出 我的名字是 Suemor 使用 interface 定义接口 使用 : 来实现接口, 类似于 Java 的 implements 关键字","link":"/2021/08/20/Kotlin%E5%AD%A6%E4%B9%A0-2/"},{"title":"自我介绍","text":"我是某职业技术学校 计算机专业 的一名废材技校生，这是一所江苏境内的五年制高职。正因为自己初中学习不够努力成绩一直处于平均水平以及热爱推广职业教育的常州 40% 多中考录取率，直到最后也没有什么彻底醒悟成绩突飞猛进只有知乎上才能看到的剧情，因此中考考了一个很平均的分数从而很不幸的进入了这一所奇怪的技校，现在即将升入三年级，也就是同龄人的高三。 我的人格是 INTJ ，是一个 十分内向 的人。当得知中考成绩后我释然了，心中毫无波动，但我知道自己的人生完蛋了。我这里中考也没有什么复读的说法，只能无奈的进入了这一所学校。学校的管理措施相比于其他技校似乎更加严格，但依旧无法挽回身边奇怪的同学智力低下的事实。 我可以肯定身边的同学根本不是来学计算机的。经历了一个学期的计算机基础的学习，我们班级较早开始了 C 语言 的课程，可是奇怪的同学依旧连计算机最基础的操作都不会，怎么可能完成编程语言的学习呢？以至于我亲眼看到我的同桌到期中考试连”Hello World”都写不出来，我无奈的笑了。 因为是技校，身边大多数人素质普遍比较低，因此 校园欺凌 是不可避免的。在班上我总能看到弱势的同学遭到强势学生过分的需求，以至于哭泣，甚至有些时候强势的学生当着部分老师的面实施欺凌，老师却能视而不见，悠哉的掏出他的手机，刷着某音，直到上课。正如同前文所说，我是一个十分内向的人，可能代码写的比其他人要好，有时候校园欺凌也会在我的头上发生，但是远不及上文同学的多，我都默默承受了。 emm 可能扯远了吧，技校的奇怪还有很多超乎你想象的，不过我不想再过多举例，下面来聊聊我自己。 “事务对我们都会有影响，其价值必须定量，而非定性地讨论。出去义务扫马路可以陶冶你的情操，还可以锻炼身体。坐在家里背单词背一天你可以学会数百个新单词，提升英语水平。按照上提到的“善意的逻辑”，这两者各有好处，仿佛难以取舍。但是我想在实际操作中，不会有人认为前者对你的益处更大。 说道理大家都清楚，但是在实际生活中，我们却总能见到某些组织的头目派手下同学站在食堂门口发传单，以“锻炼大家的社会实践能力”。我们也能见到不少同学东一榔头西一棒槌地学了许多与自己职业规划毫无关系的课程，美其名曰“扩充知识面”。 在打着各种华丽口号的诱惑面前，我们要保持清醒，并且时刻告诫自己 总有更值得做的事。” 我无法理解奇怪人的脑回路，因此我现在已经离开了班级和宿舍并加入了学校智能家居的集训队，因为是 全国职业院校技能大赛 因此难度十分低，与参加 noi 的 OIer 们完全没法比，可偏偏技校的比赛基本都是 团队型项目，也就代表着我要和奇怪的人一同比赛，我陷入了沉思。。 最后再说说自己的学习情况和对未来的展望吧~其实自己真正开始学习编程是从高职二年级开始的，因为受到了社交平台人们的启发（这个以后再聊），让我认知有很大提升，才开始踏入正轨。 现在已经过去一年了，我逐渐按时间学习了 C, Java, MySQL, SpringBoot, Android 等技术的基础（关于技术的话题以后会经常写的，本文就不展开了），现在正在学习 Android,Kotlin, C++, qt，在接下来的一年内我首先要应对技能比赛（希望队友能给点力 w），然后去学习自己薄弱的英语，多背单词和看英文文章，参加五年级的专转本考试（希望能考上个南京二本学校吧），再去学点高数并在闲暇时间看看C++ Primer, CS:APP 和它对应的 15-213 课程 然后完成相应 lab，计算机网络等书，再学学前端 Vue 等技术，有空再做算法题， 再学学 Rust?，可能的话尝试去 github 参加些开源项目。。 补充 上海交通大学生存手册 邮箱: 3100825062@qq.com","link":"/2021/08/17/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"}],"categories":[{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"}]}