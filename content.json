{"pages":[{"title":"我是谁？","text":"正如域名所示我是常州刘国钧高等职业技术学校 计算机专业 的一名废材技校生，这是一所江苏境内的五年制高职。正因为自己初中学习不够努力成绩一直处于平均水平以及热爱推广职业教育的常州 40% 多中考录取率，直到最后也没有什么彻底醒悟成绩突飞猛进只有知乎上才能看到的剧情，因此中考考了一个很平均的分数从而很不幸的进入了这一所奇怪的技校，现在即将升入三年级，也就是同龄人的高三。 我的人格是 INTJ ，是一个 十分内向 的人。当得知中考成绩后我释然了，心中毫无波动，但我知道自己的人生完蛋了。我这里中考也没有什么复读的说法，只能无奈的进入了这一所学校。学校的管理措施相比于其他技校似乎更加严格，但依旧无法挽回身边奇怪的同学智力低下的事实。 我可以肯定身边的同学根本不是来学计算机的。经历了一个学期的计算机基础的学习，我们班级较早开始了 C 语言 的课程，可是奇怪的同学依旧连计算机最基础的操作都不会，怎么可能完成编程语言的学习呢？以至于我亲眼看到我的同桌到期中考试连”Hello World”都写不出来，我无奈的笑了。 因为是技校，身边大多数人素质普遍比较低，因此 校园欺凌 是不可避免的。在班上我总能看到弱势的同学遭到强势学生过分的需求，以至于哭泣，甚至有些时候强势的学生当着部分老师的面实施欺凌，老师却能视而不见，悠哉的掏出他的手机，刷着某音，直到上课。正如同前文所说，我是一个十分内向的人，可能代码写的比其他人要好，有时候校园欺凌也会在我的头上发生，但是远不及上文同学的多，我都默默承受了。 emm 可能扯远了吧，技校的奇怪还有很多超乎你想象的，不过我不想再过多举例，下面来聊聊我自己。 “事务对我们都会有影响，其价值必须定量，而非定性地讨论。出去义务扫马路可以陶冶你的情操，还可以锻炼身体。坐在家里背单词背一天你可以学会数百个新单词，提升英语水平。按照上提到的“善意的逻辑”，这两者各有好处，仿佛难以取舍。但是我想在实际操作中，不会有人认为前者对你的益处更大。 说道理大家都清楚，但是在实际生活中，我们却总能见到某些组织的头目派手下同学站在食堂门口发传单，以“锻炼大家的社会实践能力”。我们也能见到不少同学东一榔头西一棒槌地学了许多与自己职业规划毫无关系的课程，美其名曰“扩充知识面”。 在打着各种华丽口号的诱惑面前，我们要保持清醒，并且时刻告诫自己 总有更值得做的事。” 我无法理解奇怪人的脑回路，因此我现在已经离开了班级和宿舍并加入了学校智能家居的集训队，因为是 全国职业院校技能大赛 因此难度十分低，与参加 noi 的 OIer 们完全没法比，可偏偏技校的比赛基本都是 团队型项目，也就代表着我要和奇怪的人一同比赛，我陷入了沉思。。 最后再说说自己的学习情况和对未来的展望吧~其实自己真正开始学习编程是从高职二年级开始的，因为受到了社交平台人们的启发（这个以后再聊），让我认知有很大提升，才开始踏入正轨。 现在已经过去一年了，我逐渐按时间学习了 C, Java, MySQL, SpringBoot, Android 等技术的基础（关于技术的话题以后会经常写的，本文就不展开了），现在正在学习 Android,Kotlin, C++, qt，在接下来的一年内我首先要应对技能比赛（希望队友能给点力 w），然后去学习自己薄弱的英语，多背单词和看英文文章，参加五年级的专转本考试（希望能考上个南京二本学校吧），再去学点高数并在闲暇时间看看Primer C++, CS:APP 和它对应的 15-213 课程 然后完成相应 lab，计算机网络等书，再学学前端 Vue 等技术，有空再做算法题， 再学学 Rust?，可能的话尝试去 github 参加些开源项目。。 补充 上海交通大学生存手册 邮箱: 3100825062@qq.com","link":"/about/index.html"}],"posts":[{"title":"『Kotlin 教程 (1)』 变量、逻辑控制语句、类与空安全机制","text":"大家好我又来更新博客啦，最近自己正在学习用 Kotlin 来编写 Android，决定写篇博客来巩固自身 Kotlin 语法。本博客尽可能采用 Kotlin 与 Java 互相对照方式来呈现，因此需要读者有一定的 Java 基础。 有关 Kotlin 的发展历史和环境搭建之类的请自行搜寻，毕竟大家也有一定的编程基础，就不再介绍了。 Kotlin 的基本数值类型包括Int、Long、Short、Float、Double、Boolean、Char、Byte 等，用法上与 Java 没有区别，但请仔细观察他们的大小写，避免不必要的错误。 变量Kotlin 的变量分为可变变量（var）和不可变变量(val) 12345678// 对应的 Kotlin 代码如下var &lt; 标识符 &gt; : &lt; 类型 &gt; = &lt; 初始化值 &gt; // 可变变量var a : Int = 1 // 为可变变量整型 a 赋值为 1val &lt; 标识符 &gt; : &lt; 类型 &gt; = &lt; 初始化值 &gt; // 不可变变量val b: Int = 1 // 为不可变变量整型 a 赋值为 1print(&quot;a 的大小为 -&gt;$a&quot;) // 输出 a 123456// 对应的 Java 代码如下int a = 1;final int b = 1； System.out.println(&quot;a 的大小为 -&gt;&quot; + a); 在我们编写代码中一般优先考虑val（不可变变量） 从上述代码可以很明显的发现 Kotlin 是 先写标识符后写类型的，这点可能会不太习惯，需要多加练习 $ 符号表示引用的意思。这里理解为 字符串模板，可快捷的对变量进行操作 每一行代码的结束可以省略掉分号 ; 第一次写可能会有一点不习惯。 编译器支持自动类型判断, 即声明时可以 不指定类型, 由编译器判断，因此上述代码可改为如下，我们应该尽可能的采用这种方式赋值 123var a = 1 // 为可变变量整形 a 赋值为 1val a = 1 // 为不可变变量整形 a 赋值为 1 for 循环 Kotlin 废除了 Java 中的 for(初始值; 条件; 增减步长) 这个规则。但是 Kotlin 中对于 for 循环语句新增了其他的规则，来满足我们的需求 123456789101112131415for(i in 0 until 3){ print(&quot;$i &quot;) // 输出 0 1 2 即为[n,m) 大于等于 n, 小于 m}for (i in 3 downTo 0){ print(&quot;$i &quot;) // 输出 3 2 1 0 即为[n,m] 小于等于 n, 大于等于 m ,n &gt; m}for (i in 0..3){ print(&quot;$i &quot;) // 输出 0 1 2 3 即为[n,m] 大于等于 n，小于等于 m}for (i in 0..3 step 2){ print(&quot;$i &quot;) // 输出 0 2 即设置步长为 2} 12345678910111213141516// 对应的 Java 代码for (int i = 0; i &lt; 3; i++) { System.out.print(i + &quot; &quot;);}for (int i = 3; i &gt;= 0 ; i--) { System.out.print(i + &quot; &quot;);}for (int i = 0; i &lt;= 3; i++) { System.out.print(i + &quot; &quot;);}for (int i = 0; i &lt;= 3; i=i+2) { System.out.print(i + &quot; &quot;);} 这里不再过多叙述，请仔细揣摩 When 语句 在 Kotlin 中废除了 Java 的 switch 语句，改为 When 语句，When 语句非常强大，还可以替代 if else() 语句 12345678when(3){ 1 -&gt; print(&quot;1&quot;) 2 -&gt; print(&quot;2&quot;) else -&gt;{ print(&quot;3&quot;) }}// 最终输出 3 1234567891011// 对应 java 代码switch (3){ case 1: System.out.print(&quot;1&quot;); break; case 2: System.out.print(&quot;2&quot;); break; default: System.out.print(&quot;3&quot;);} 这里只做简单介绍，请自己多加摸索 类的使用以及声明可空变量 Kotlin 和 Java 一样也有类和方法，但在 Kotlin 中我们一般把方法称之为 函数，类和函数的定义如下 12345678910111213141516class a { // 类名为 a private val age = 15 private lateinit var name: String // 声明一个变量并延迟初始化 private var hobby: String? = null // 要给变量赋值为 null 或 0 时，需要在类型后加？ // private val num2 会报错，Kotlin 在类中的基本数值类型必须初始化且无法使用 lateinit 延迟初始化 fun say() { // num = 17 报错，因为声明的是 val 所以不能修改 name = &quot; 张三 &quot; print(&quot; 我叫$name，今年${age} 岁了 &quot;) } // 成员函数}fun main() { val b:a = a() // 实例化 b.say() // 调用函数 sum 输出: 我叫张三，今年 15 岁了} 12345678910111213141516// 对应的 Java 代码class a{ private final int age = 15; private String name; private String hobby = null; void say(){ name = &quot; 张三 &quot;; System.out.println(&quot; 我叫 &quot; + name + &quot;, 今年 &quot; + age + &quot; 岁了 &quot;); } public static void main(String[] args) { final a b = new b(); b.say(); }} Kotlin 没有 new 关键字 由于 Kotlin 的空安全机制，可以有效防止程序出现空指针异常，因此需要进行额外的处理 创建成员对象必须初始化，如果不初始化，需使用 lateinit 关键字 基本数值类型无法使用 lateinit 关键字，必须赋值 要给变量赋值为 null 或 0 时，需要在类型后加?","link":"/2021/08/19/Kotlin%E5%AD%A6%E4%B9%A0-1/"},{"title":"AndroidV5 包源码解析","text":"今年智能家居安装与维护中职组省赛还有 1 个多月就要开始了，作为一名负责 Android 开发的蒟蒻，来介绍一下刚更新的 SmartHomeV5 包源码吧~ 其实 V5 包的源码并不难理解，结合代码片段的注释是很好理解的，我先给出我所写好的示例 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class MainActivity extends AppCompatActivity { String name,time; double temperature,humidity,illumination; Handler handler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findView(); } private void findView() { // 连接服务器 ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;); SocketClient.getInstance().creatConnect(); SocketClient.getInstance().login(new LoginCallback() { @Override public void onEvent(String var1) { runOnUiThread(new Runnable() { @Override public void run() { if (var1.equals(ConstantUtil.Success)) { Toast.makeText(MainActivity.this, &quot; 连接成功 &quot;, Toast.LENGTH_SHORT).show(); } else if (var1.equals(ConstantUtil.Reconnect)){ Toast.makeText(MainActivity.this, &quot; 重新连接 &quot;, Toast.LENGTH_SHORT).show(); }else { Toast.makeText(MainActivity.this, &quot; 连接失败 &quot;, Toast.LENGTH_SHORT).show(); } } }); } }); new Handler().postDelayed(new Runnable() { @Override public void run() { // 单控 ControlUtils.control(&quot;WarningLight&quot;, &quot;10&quot;, ConstantUtil.CmdCode_1, ConstantUtil.Channel_ALL, ConstantUtil.Open); // 获取数据 ControlUtils.getData(); ControlUtils.getFaceData(); SocketClient.getInstance().getData(new DataCallback&lt;DeviceBean&gt;() { @SuppressLint(&quot;HandlerLeak&quot;) @Override public void onResult(DeviceBean deviceBean) { try { if (!TextUtils.isEmpty(deviceBean.getTime())){ time = deviceBean.getTime(); } } catch (Exception e) { e.printStackTrace(); } try { if (!TextUtils.isEmpty(deviceBean.getName())){ name = deviceBean.getName(); } } catch (Exception e) { e.printStackTrace(); } if (deviceBean.getDevice().size() &gt; 0){ for (int i = 0; i &lt; deviceBean.getDevice().size(); i++) { try { if (deviceBean.getDevice().get(i).getBoardId().equals(&quot;1&quot;)){ if (deviceBean.getDevice().get(i).getSensorType().equals(ConstantUtil.Illumination)){ temperature = Double.parseDouble(deviceBean.getDevice().get(i).getValue()); }else{ humidity = Double.parseDouble(deviceBean.getDevice().get(i).getValue()); } } } catch (NumberFormatException e) { e.printStackTrace(); } try { if (deviceBean.getDevice().get(i).getBoardId().equals(&quot;2&quot;)){ illumination = Double.parseDouble(deviceBean.getDevice().get(i).getValue()); } } catch (NumberFormatException e) { e.printStackTrace(); } } } } }); } },500); }} 连接服务器代码解析 好了话不多说，我们看看连接服务器的代码 1234567891011121314151617181920// 连接服务器ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;);SocketClient.getInstance().creatConnect();SocketClient.getInstance().login(new LoginCallback() { @Override public void onEvent(String var1) { runOnUiThread(new Runnable() { @Override public void run() { if (var1.equals(ConstantUtil.Success)) { Toast.makeText(MainActivity.this, &quot; 连接成功 &quot;, Toast.LENGTH_SHORT).show(); } else if (var1.equals(ConstantUtil.Reconnect)){ Toast.makeText(MainActivity.this, &quot; 重新连接 &quot;, Toast.LENGTH_SHORT).show(); }else { Toast.makeText(MainActivity.this, &quot; 连接失败 &quot;, Toast.LENGTH_SHORT).show(); } } }); }}); 别看这只有几行代码，其实已经执行完 V5 包里几乎全部的代码了 creatConnect()方法 单例模式的运用 我们进入登录的 SocketClient.getInstance().creatConnect(); 的里面，这里涉及到一个单例模式，实例化唯一的 SocketClient 对象。 1234567// 我们调用 SocketClient.getInstance().XXXX()的时候这个方法都会被调用，也就是单例模式，用来实例化唯一的 SocketClient 对象 public static SocketClient getInstance() { if (null == mInstance) { mInstance = new SocketClient(); } return mInstance; } 启动 InitSocketThread 线程 接着我们看到如下，请仔细观看注释 ， 注意：通过源码我们可以看出，我们写代码每执行 SocketClient.getInstance().creatConnect() 就会断开一下与服务器的连接，因此请不要把这句话放在 Fragment 里或者多次执行 123456789101112131415// 如果之前已经连接过服务器，再次调用 creatConnect()会断开现有连接再重新连接服务器，因此 creatConnect()要谨慎调用 public boolean creatConnect() { // 第一次创建则为空，因此会执行 InitSocketThread() 的线程 if (this.mSocket == null) { // 开启连接服务器线程 (new SocketClient.InitSocketThread()).start(); } else { // 用来断开与服务器连接。 this.release(); // 开启连接服务器线程 (new SocketClient.InitSocketThread()).start(); } return false;} 我们假设初次调用 creatConnect() 方法，便会开启 (new SocketClient.InitSocketThread()).start() 线程， 如下我们进入这个线程，这个线程意义不大，直接调用了 SocketClient.this.initSocket() 方法 12345678910// 执行 initSocket()方法用的class InitSocketThread extends Thread { InitSocketThread() { } public void run() { super.run(); SocketClient.this.initSocket(); }} V5 包核心 initSocket()方法 如下我们进入 SocketClient.this.initSocket() 方法，这是整个 V5 包的核心代码，请 仔细仔细再仔细阅读注释 12345678910111213141516171819202122232425262728293031//V5 源码的核心方法！！！！private void initSocket() { try { // 创建并实例化 socket Socket socket = new Socket(); // 连接服务器，ip 为我们之前 &quot;ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;);&quot; 中的 &quot;127.0.0.1&quot;，端口号是定死的 (6006) 无法更改 socket.connect(new InetSocketAddress(ip, this.port), 3000); // 把已经连接服务器的 socket 赋值给全局的 mSocket。这里的 mSocket 和 Socket 是弱引用，不严谨的说可以直接理解为创建 Socket 实例对象 this.mSocket = new WeakReference(socket); // 把我们的之前 &quot;ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;);&quot; 中的 &quot;bizideal&quot;, &quot;123456&quot; 发送给服务器，可以去看 sendData() ControlUtils.getData(); // 实例化 ReadThread 对象，ReadThread 的线程是用来获取服务器数据的 this.mReadThread = new SocketClient.ReadThread((Socket)this.mSocket.get()); // 启动实例化 ReadThread 线程，获取服务器数据的 this.mReadThread.start(); // 执行心跳包，检测是否掉线 this.mHandler.postDelayed(this.heartBeatRunnable, 10000L); // 成功连接服务器则都不为空 if (this.mSocket != null &amp;&amp; this.mLoginCallback != null) { // 根据 ConstantUtil, 会 Toast 连接成功 this.mLoginCallback.onEvent(&quot;0&quot;); } } catch (IOException var2) { if (this.mLoginCallback != null) { // 根据 ConstantUtil, 会 Toast 连接失败, 无法连接服务器 this.mLoginCallback.onEvent(&quot;1&quot;); } // 断开服务器连接 this.disConnect(this.mSocket); }} 上面代码可能比较难理解，不过我们可以把它拆分成 3 部分 ControlUtils.getData();请求数据 this.mReadThread = new SocketClient.ReadThread((Socket)this.mSocket.get());this.mReadThread.start();接收数据 this.mHandler.postDelayed(this.heartBeatRunnable, 10000L);心跳包检测连接服务器状态 请求数据 进入 ControlUtils.getData() 里，这里比较简单，就是发送 JSON 请求给服务器，表明需要得到数据 123456789101112131415// 数据采集public static boolean getData() { try { JSONObject object = new JSONObject(); object.put(&quot;Type&quot;, &quot;GetDevicState&quot;); object.put(&quot;UserName&quot;, mUserName); object.put(&quot;Password&quot;, mPassword); object.put(&quot;CurrentTime&quot;, (new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)).format(new Date())); // 把 JSON 请求发送给服务器 SocketClient.getInstance().sendData(object.toString()); } catch (JSONException var1) { var1.printStackTrace(); } return true;} 接着进入 SocketClient.getInstance().sendData(object.toString()); 仔细观看注释，发送数据给服务器其中 msg 是刚刚在 ControlUtils 中创建的 JSON 数据，最终会将这个数据发送给服务器。另外注意 SocketClient.this.sendTime = System.currentTimeMillis() 获取发送数据的时间，在第三部分心跳包检测会用的。OK 非常简单，第一部分发送数据就是这个流程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 发送数据给服务器其中 msg 是在 ControlUtils 中创建的 JSON 数据，这里的 boolean 返回值后续会用做“心跳包“检测 public boolean sendData(final String msg) { // 老规矩检查你是否连接了服务器 if (null != this.mSocket &amp;&amp; null != this.mSocket.get()) { // 把全局 mSocket 赋值给局部的 soc final Socket soc = (Socket)this.mSocket.get(); try { // 老规矩检查你是否连接了服务器 if (!soc.isClosed() &amp;&amp; !soc.isOutputShutdown()) { // 用流来发送数据，不过多解释 (new Thread(new Runnable() { public void run() { try { // 用流来发送数据，不过多解释 PrintWriter DataWrite = new PrintWriter(soc.getOutputStream()); DataWrite.write(msg + &quot;\\r\\n&quot;); DataWrite.flush(); //isSocket 是用来判断是否发送成功的 SocketClient.this.isSocket = true; //sendTime 获取发送数据的时间，会在另一个线程使用到，判断连接状态 SocketClient.this.sendTime = System.currentTimeMillis(); } catch (IOException var2) { var2.printStackTrace(); //isSocket 是用来判断是否发送成功的 SocketClient.this.isSocket = false; } } })).start(); } else { //isSocket 是用来判断是否发送成功的 this.isSocket = false; } } catch (Exception var4) { var4.printStackTrace(); //isSocket 是用来判断是否发送成功的 this.isSocket = false; } //isSocket 是用来判断是否发送成功的 return this.isSocket; } else { return false; } } 接收数据 我们回到 V5 包的核心 initSocket 方法，看到如下代码，其中 ReadThread 就是用来接收数据的 1234// 实例化 ReadThread 对象，ReadThread 的线程是用来获取服务器数据的this.mReadThread = new SocketClient.ReadThread((Socket)this.mSocket.get());// 启动实例化 ReadThread 线程，获取服务器数据的this.mReadThread.start(); 进入上方 ReadThread 这个线程，仔细观看注释，这个线程往往使用来响应刚才的请求数据，用来读取服务器发送给我们的数据，会得到一串 服务器响应给我们的 JSON 数据 ，最后交给SocketClient.this.setData(obj) 解析，最终赋值到 DeviceBean 这个类中，供我们直接使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 获取服务器数据 private class ReadThread extends Thread { // 弱引用局部 Socket private WeakReference&lt;Socket&gt; mWeakSocket; private boolean isStart = true; public ReadThread(Socket socket) { // 转移全局 Socket this.mWeakSocket = new WeakReference(socket); } // 断开服务器连接 public void release() { this.isStart = false; // 断开服务器连接 SocketClient.this.disConnect(this.mWeakSocket); } // 获取服务器数据 public void run() { super.run(); // 梅开 n 度, 把局部的 mWeakSocket 转移给线程内的 socket Socket socket = (Socket)this.mWeakSocket.get(); // 判空 if (socket != null) { try { String response = &quot;&quot;; // 读取服务器数据 BufferedReader DataRead = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 判空 while(!socket.isClosed() &amp;&amp; this.isStart &amp;&amp; !socket.isInputShutdown()) { // 判空 while((response = DataRead.readLine()) != null) { // 获取服务器返回的 JSON 数据 JSONObject obj = new JSONObject(response); // 解析服务器 JSON 数据 SocketClient.this.setData(obj); } } } catch (JSONException var5) { var5.printStackTrace(); } catch (Exception var6) { // 未知异常就断开服务器连接 this.isStart = false; SocketClient.this.mSocket = null; var6.printStackTrace(); } } } } 下方是 SocketClient.this.setData(obj) 解析我们收到的 JSON 数据，解析完成后，也就是我们 MainActivity 最终调用 SocketClient.getInstance().getData() 的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 解析服务器返回的 JSON 数据public void setData(JSONObject obj) throws JSONException { DeviceBean bean = new DeviceBean(); if (obj.has(&quot;Type&quot;)) { // 判断数据是数据采集还是考勤机或心跳包的 if (!obj.getString(&quot;Type&quot;).toString().equals(&quot;Upload&quot;) &amp;&amp; !obj.getString(&quot;Type&quot;).toString().equals(&quot;GetDevicState&quot;)) { // 判断是否为考勤机 if (obj.getString(&quot;Type&quot;).toString().equals(&quot;UploadPersonInfo&quot;) || obj.getString(&quot;Type&quot;).toString().equals(&quot;GetCurrentAttendance&quot;)) { try { if (obj.has(&quot;Name&quot;)) { // 考勤的姓名 DeviceBean.setName(obj.getString(&quot;Name&quot;)); } } catch (JSONException var9) { } try { if (obj.has(&quot;Time&quot;)) { // 考勤的日期 DeviceBean.setTime(obj.getString(&quot;Time&quot;)); } } catch (JSONException var8) { } if (mDataCallback != null) { mDataCallback.onResult(bean); } } } else { // 这里是数据采集的 JSON 解析 try { // 具体怎么解析 JSON 就不说明了 ArrayList&lt;Devices&gt; deviceList = new ArrayList(); JSONArray array = new JSONArray(obj.get(&quot;Data&quot;).toString()); for(int i = 0; i &lt; array.length(); ++i) { JSONObject jsonObject = array.getJSONObject(i); Devices devices = new Devices(); // 数据的值 devices.setValue(jsonObject.getString(&quot;Value&quot;)); // 类型 devices.setSensorType(jsonObject.getString(&quot;SensorType&quot;)); // 版号 devices.setBoardId(jsonObject.getString(&quot;BoardId&quot;)); deviceList.add(devices); } // 解析完的数据放进 DeviceBean 集合中 DeviceBean.setDevice(deviceList); } catch (JSONException var10) { } // 如果写了获取数据的回调，就执行可以拿到数据了 if (mDataCallback != null) { mDataCallback.onResult(bean); } } } else if (obj.has(&quot;state&quot;) &amp;&amp; obj.getString(&quot;state&quot;).toString().equals(&quot;Failure&quot;) &amp;&amp; obj.has(&quot;msg&quot;) &amp;&amp; this.mLoginCallback != null) { // 未知错误 this.mLoginCallback.onEvent(&quot;5&quot;); }} 心跳包检测 我们回到 V5 包的核心 initSocket 方法，看到如下代码，这里开启 heartBeatRunnable 用于心跳包检测，当你超过 10 秒钟没有发送数据给服务器便会执行，应用服务器心跳检测，简称“心跳包”，检测你是否掉线，其中 SocketClient.this.sendTime 就是第一部分，请求数据接收的时间 12// 执行心跳包，检测是否掉线this.mHandler.postDelayed(this.heartBeatRunnable, 10000L); 12345678910111213141516171819202122232425262728293031323334// 用来开启下方 heartBeatRunnable 线程，详情看 initSocket()方法 private Handler mHandler = new Handler();// 配合上方 mHandler 开启线程 详情看 initSocket() 方法// 判断你是否掉线private Runnable heartBeatRunnable = new Runnable() { public void run() { try { // 当你超过 10 秒钟没有发送数据给服务器变会执行，应用服务器心跳检测，简称“心跳包”，检测你是否掉线，SocketClient.this.sendTime 就是第一部分，请求数据接收的时间 if (System.currentTimeMillis() - SocketClient.this.sendTime &gt;= 10000L) { // 发送心跳包 boolean isSuccess = SocketClient.this.sendData(&quot;{\\&quot;Type\\&quot;: \\&quot;HeartBeat\\&quot;}&quot;); // 如果掉线 if (!isSuccess) { // 如果你调用了 LoginCallback 回调，就!=null if (SocketClient.this.mLoginCallback != null) { // 根据 ConstantUtil 的 public static String Reconnect = &quot;2&quot;; 会 Toast 出“重新连接 &quot; SocketClient.this.mLoginCallback.onEvent(&quot;2&quot;); } // 停止这个 heartBeatRunnable 线程 SocketClient.this.mHandler.removeCallbacks(SocketClient.this.heartBeatRunnable); // 断开服务器连接 SocketClient.this.mReadThread.release(); // 重新建立服务器连接 (SocketClient.this.new InitSocketThread()).start(); } } // 以每 15 秒频率重复执行心跳包 SocketClient.this.mHandler.postDelayed(this, 15000L); } catch (Exception var2) { var2.printStackTrace(); } }}; 总结 &amp;&amp; 源码 以上便是 V5 包源码的全部核心，剩下一部分没有提到的都很好理解，相信可以做到举一反三吧 emmmmm，如果有什么不明白的可以发送邮件到 1502972236zwj@gmail.com 与我联系，最后附上全部SocketClien 类的源码注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363package com.bizideal.smarthome.socket;import android.os.Handler;import com.bizideal.smarthome.socket.DeviceBean.Devices;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.lang.ref.WeakReference;import java.net.InetSocketAddress;import java.net.Socket;import java.util.ArrayList;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;//V5 连接服务器核心类 public class SocketClient { //SocketClient(也就是自己) 的实例对象 private static SocketClient mInstance; // 获取数据回调 private static DataCallback mDataCallback; // 创建全局 Socket 的弱引用，不严谨的说可以直接理解为创建 Socket 实例对象 private WeakReference&lt;Socket&gt; mSocket; // 创建 ReadThread 对象，ReadThread 的线程是用来获取服务器数据的 public SocketClient.ReadThread mReadThread; // 每次向服务器发送数据的时间, 详情看 sendData() 方法 private long sendTime = 0L; //ip 在 ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;); 会对其赋值 public static String ip = &quot;10.1.3.173&quot;; // 定死的服务器断开号，无法更改 int port = 6006; // 登录回调 private LoginCallback mLoginCallback; // 没用 private Boolean isSuccess = false; // 用来开启下方 heartBeatRunnable 线程，详情看 initSocket() 方法 private Handler mHandler = new Handler(); // 配合上方 mHandler 开启线程 详情看 initSocket() 方法 // 判断你是否掉线 private Runnable heartBeatRunnable = new Runnable() { public void run() { try { // 当你超过 10 秒钟没有发送数据给服务器便会执行，应用服务器心跳检测，简称“心跳包”，检测你是否掉线， if (System.currentTimeMillis() - SocketClient.this.sendTime &gt;= 10000L) { // 发送心跳包 boolean isSuccess = SocketClient.this.sendData(&quot;{\\&quot;Type\\&quot;: \\&quot;HeartBeat\\&quot;}&quot;); // 如果掉线 if (!isSuccess) { // 如果你调用了 LoginCallback 回调，就!=null if (SocketClient.this.mLoginCallback != null) { // 根据 ConstantUtil 的 public static String Reconnect = &quot;2&quot;; 会 Toast 出“重新连接 &quot; SocketClient.this.mLoginCallback.onEvent(&quot;2&quot;); } // 停止这个 heartBeatRunnable 线程 SocketClient.this.mHandler.removeCallbacks(SocketClient.this.heartBeatRunnable); // 断开服务器连接 SocketClient.this.mReadThread.release(); // 重新建立服务器连接 (SocketClient.this.new InitSocketThread()).start(); } } // 以每 15 秒频率重复执行心跳包 SocketClient.this.mHandler.postDelayed(this, 15000L); } catch (Exception var2) { var2.printStackTrace(); } } }; // 这是一个 flag 用来判断是否成功发送数据给服务器 private boolean isSocket = false; public SocketClient() { } // 我们调用 SocketClient.getInstance().XXXX() 的时候这个方法都会被调用，也就是单例模式，用来实例化唯一的 SocketClient 对象 public static SocketClient getInstance() { if (null == mInstance) { mInstance = new SocketClient(); } return mInstance; } public boolean creatConnect() { // 第一次创建则为空，因此会执行 InitSocketThread() 的线程 if (this.mSocket == null) { // 开启连接服务器线程 (new SocketClient.InitSocketThread()).start(); } else { // 如果之前已经连接过服务器，再次调用 creatConnect() 会断开现有连接再重新连接服务器，因此 creatConnect()要谨慎调用 this.release(); // 开启连接服务器线程 (new SocketClient.InitSocketThread()).start(); } return false; } //V5 源码的核心方法！！！！ private void initSocket() { try { // 创建并实例化 socket Socket socket = new Socket(); // 连接服务器，ip 为我们之前 &quot;ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;);&quot; 中的 &quot;127.0.0.1&quot;，端口号是定死的(6006) 无法更改 socket.connect(new InetSocketAddress(ip, this.port), 3000); // 把已经连接服务器的 socket 赋值给全局的 mSocket this.mSocket = new WeakReference(socket); // 把我们的之前 &quot;ControlUtils.setUser(&quot;bizideal&quot;, &quot;123456&quot;, &quot;127.0.0.1&quot;);&quot; 中的 &quot;bizideal&quot;, &quot;123456&quot; 发送给服务器，可以去看 sendData() ControlUtils.getData(); // 实例化 ReadThread 对象，ReadThread 的线程是用来获取服务器数据的 this.mReadThread = new SocketClient.ReadThread((Socket)this.mSocket.get()); // 启动实例化 ReadThread 线程，获取服务器数据的 this.mReadThread.start(); // 执行心跳包，检测是否掉线 this.mHandler.postDelayed(this.heartBeatRunnable, 10000L); // 成功连接服务器则都不为空 if (this.mSocket != null &amp;&amp; this.mLoginCallback != null) { // 根据 ConstantUtil, 会 Toast 连接成功 this.mLoginCallback.onEvent(&quot;0&quot;); } } catch (IOException var2) { if (this.mLoginCallback != null) { // 根据 ConstantUtil, 会 Toast 连接失败, 无法连接服务器 this.mLoginCallback.onEvent(&quot;1&quot;); } // 断开服务器连接 this.disConnect(this.mSocket); } } // 发送数据给服务器其中 msg 是在 ControlUtils 中创建的 JSON 数据，这里的 boolean 返回值后续会用做“心跳包“检测 public boolean sendData(final String msg) { // 老规矩检查你是否连接了服务器 if (null != this.mSocket &amp;&amp; null != this.mSocket.get()) { // 把全局 mSocket 赋值给局部的 soc final Socket soc = (Socket)this.mSocket.get(); try { // 老规矩检查你是否连接了服务器 if (!soc.isClosed() &amp;&amp; !soc.isOutputShutdown()) { // 用流来发送数据，不过多解释 (new Thread(new Runnable() { public void run() { try { // 用流来发送数据，不过多解释 PrintWriter DataWrite = new PrintWriter(soc.getOutputStream()); DataWrite.write(msg + &quot;\\r\\n&quot;); DataWrite.flush(); //isSocket 是用来判断是否发送成功的 SocketClient.this.isSocket = true; //sendTime 获取发送数据的时间，会在另一个线程使用到，判断连接状态 SocketClient.this.sendTime = System.currentTimeMillis(); } catch (IOException var2) { var2.printStackTrace(); //isSocket 是用来判断是否发送成功的 SocketClient.this.isSocket = false; } } })).start(); } else { //isSocket 是用来判断是否发送成功的 this.isSocket = false; } } catch (Exception var4) { var4.printStackTrace(); //isSocket 是用来判断是否发送成功的 this.isSocket = false; } //isSocket 是用来判断是否发送成功的 return this.isSocket; } else { return false; } } // 解析服务器返回的 JSON 数据 public void setData(JSONObject obj) throws JSONException { DeviceBean bean = new DeviceBean(); if (obj.has(&quot;Type&quot;)) { // 判断数据是数据采集还是考勤机或心跳包的 if (!obj.getString(&quot;Type&quot;).toString().equals(&quot;Upload&quot;) &amp;&amp; !obj.getString(&quot;Type&quot;).toString().equals(&quot;GetDevicState&quot;)) { // 判断是否为考勤机 if (obj.getString(&quot;Type&quot;).toString().equals(&quot;UploadPersonInfo&quot;) || obj.getString(&quot;Type&quot;).toString().equals(&quot;GetCurrentAttendance&quot;)) { try { if (obj.has(&quot;Name&quot;)) { // 考勤的姓名 DeviceBean.setName(obj.getString(&quot;Name&quot;)); } } catch (JSONException var9) { } try { if (obj.has(&quot;Time&quot;)) { // 考勤的日期 DeviceBean.setTime(obj.getString(&quot;Time&quot;)); } } catch (JSONException var8) { } if (mDataCallback != null) { mDataCallback.onResult(bean); } } } else { // 这里是数据采集的 JSON 解析 try { // 具体怎么解析 JSON 就不说明了 ArrayList&lt;Devices&gt; deviceList = new ArrayList(); JSONArray array = new JSONArray(obj.get(&quot;Data&quot;).toString()); for(int i = 0; i &lt; array.length(); ++i) { JSONObject jsonObject = array.getJSONObject(i); Devices devices = new Devices(); // 数据的值 devices.setValue(jsonObject.getString(&quot;Value&quot;)); // 类型 devices.setSensorType(jsonObject.getString(&quot;SensorType&quot;)); // 版号 devices.setBoardId(jsonObject.getString(&quot;BoardId&quot;)); deviceList.add(devices); } // 解析完的数据放进 DeviceBean 集合中 DeviceBean.setDevice(deviceList); } catch (JSONException var10) { } // 如果写了获取数据的回调，就执行可以拿到数据了 if (mDataCallback != null) { mDataCallback.onResult(bean); } } } else if (obj.has(&quot;state&quot;) &amp;&amp; obj.getString(&quot;state&quot;).toString().equals(&quot;Failure&quot;) &amp;&amp; obj.has(&quot;msg&quot;) &amp;&amp; this.mLoginCallback != null) { // 未知错误 this.mLoginCallback.onEvent(&quot;5&quot;); } } // 断开服务器连接 public void disConnect(WeakReference&lt;Socket&gt; mSocket) { try { if (mSocket != null) { Socket sk = (Socket)mSocket.get(); if (!sk.isClosed()) { sk.close(); } sk = null; mSocket = null; } } catch (IOException var3) { var3.printStackTrace(); } } // 断开服务器连接 public void release() { try { if (mInstance != null) { mInstance = null; } if (this.mReadThread != null) { this.mReadThread.release(); } if (this.mHandler != null) { this.mHandler.removeCallbacks(this.heartBeatRunnable); } } catch (Exception var2) { } } // 连接服务器的 LoginCallback 赋值给全局 mLoginCallback public void login(LoginCallback callback) { this.mLoginCallback = callback; } public void getData(DataCallback callback) { mDataCallback = callback; } // 获取服务器数据 private class ReadThread extends Thread { // 局部 Socket private WeakReference&lt;Socket&gt; mWeakSocket; private boolean isStart = true; public ReadThread(Socket socket) { // 转移全局 Socket this.mWeakSocket = new WeakReference(socket); } // 断开服务器连接 public void release() { this.isStart = false; // 断开服务器连接 SocketClient.this.disConnect(this.mWeakSocket); } // 获取服务器数据 public void run() { super.run(); // 梅开 n 度, 把局部的 mWeakSocket 转移给线程内的 socket Socket socket = (Socket)this.mWeakSocket.get(); // 判空 if (socket != null) { try { String response = &quot;&quot;; // 读取服务器数据 BufferedReader DataRead = new BufferedReader(new InputStreamReader(socket.getInputStream())); // 判空 while(!socket.isClosed() &amp;&amp; this.isStart &amp;&amp; !socket.isInputShutdown()) { // 判空 while((response = DataRead.readLine()) != null) { // 获取服务器返回的 JSON 数据 JSONObject obj = new JSONObject(response); // 解析服务器 JSON 数据 SocketClient.this.setData(obj); } } } catch (JSONException var5) { var5.printStackTrace(); } catch (Exception var6) { // 未知异常就断开服务器连接 this.isStart = false; SocketClient.this.mSocket = null; var6.printStackTrace(); } } } } // 执行 initSocket() 方法用的 class InitSocketThread extends Thread { InitSocketThread() { } public void run() { super.run(); SocketClient.this.initSocket(); } }}","link":"/2021/11/06/AndroidV5%E5%8C%85%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"『Kotlin 教程 (2)』 构造器、继承、接口","text":"这里是 Kotlin 基础教程的第二篇，本篇会简单快速的介绍 Kotlin 面向对象的几个重点。因博主自身也是个菜鸡，博文可能会出现错误，还请多多指教。另外本博客尽可能采用 Kotlin 与 Java 互相对照方式来呈现，因此需要读者有一定的 Java 基础。 构造器 Kotlin 的构造器写法与 Java 有些不同。在 Kotlin 中，允许有一个主构造函数和多个二级构造函数（辅助构造函数），其中主构造函数是类头的一部分。构造器一般用关键字constructor 表示，请仔细看下面例子 123456789101112131415class Test constructor(num1:Int) { // constructor 也可以省略 即 class a (num1:Int) { init { println(&quot;num1 = $num1&quot;) // 使用 init 可以对主构造器里值进行操作 } constructor(num1: Int,num2 : Int):this(num1){ // 这是二级构造，也就是 java 中的构造器重载 println(num1 + num2) }}fun main() { val test1:Test = Test(1) // 调用主构造实例化对象 val test2:Test = Test(1,2) // 调用主构造和二级构造实例化对象} 12345678910111213141516171819202122// 对应 Java 代码，未必完全对应，但思路一致public class Test { private int num1; private int num2; public Test(int num1){ this.num1 = num1; System.out.println(&quot;num1 = &quot; + num1); } public Test(int num1,int num2){ this(num1); this.num2 = num2; System.out.println(num1+num2); } public static void main(String[] args) { Test test1 = new Test(1); Test test2 = new Test(1,2); }} 结果输出 num1 = 1num1 = 13 请仔细对比观察，应当很好理解，对应 java 代码仅供参考，并非完全一致 Kotlin 实例化对象没有 new 关键字 主构造的 constructor 可以省略 构造器也可以赋初值class Test constructor(num1:Int = 1) {} ，但用的不多，如需了解请自行查阅资料 关于 get 和 set 方法，kotlin 自动生成，无需主动去写，想要详细了解请自行查阅资料 继承 Kotlin 继承写法与 Java 也有少些不同，定义继承类需要额外使用关键字 open。不管是类、还是成员都需要使用open 关键字。定义格式如下 1234567open class 类名{ open var/val 属性名 = 属性值 open fun 函数名() } 请看下面例子 123456789101112131415161718192021222324252627282930open class Person(name:String) {// 必须使用 open 关键字这个类才能被继承！这里是省略 constructor 关键字的主构造 constructor(name:String,age:Int):this(name){// 函数重载 println(&quot; 父类构造完成创建 &quot;) } open fun study(){ // 使用 open 关键字允许子类重写 println(&quot; 我上高中了 &quot;) }}class Student(name: String, age: Int,id:String,score:Int) : Person(name, age){//Student 类继承 Person 类。Person(name, age) 这里类似于 Java 的 super init { println(&quot; 子类构造完成创建 &quot;) println(&quot;name = $name&quot;) println(&quot;age = $age&quot;) println(&quot;id = $id&quot;) println(&quot;score = $score&quot;) } override fun study() { println(&quot; 我上技校了 &quot;) // 子类重写 study 方法 }}fun main() { val goodStudent:Person = Person(&quot; 张三 &quot;,17) // 实例化父类 goodStudent.study() // 调用父类 study 方法 println() val badStudent:Student = Student(&quot;Suemor&quot;,17,&quot;sb123&quot;,80) // 实例化子类 badStudent.study() // 调用子类重写父类的 study 方法} 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 对应 Java 代码，未必完全对应，但思路一致public class Person { private String name; private int age; public Person(String name){ this.name = name; } public Person(String name,int age){ this(name); this.age = age; System.out.println(&quot; 父类二级构造完成创建 &quot;); } public void study(){ System.out.println(&quot; 我上高中了 &quot;); }}class Student extends Person{ private String id; private int score; public Student(String name, int age,String id,int score) { super(name, age); this.id = id; this.score = score; System.out.println(&quot; 子类构造完成创建 &quot;); System.out.println(&quot;name = &quot; + name); System.out.println(&quot;age = &quot; + age); System.out.println(&quot;id = &quot; + id); System.out.println(&quot;score = &quot; + score); } @Override public void study() { System.out.println(&quot; 我上技校了 &quot;); } public static void main(String[] args) { Person goodStudent = new Person(&quot; 张三 &quot;, 17); goodStudent.study(); System.out.println(); Student badStudent = new Student(&quot;Suemor&quot;, 17, &quot;sb123&quot;, 80); badStudent.study(); }} 最终输出 父类构造完成创建 我上高中了 父类构造完成创建 子类构造完成创建 name = Suemorage = 17id = sb123score = 80 我上技校了 继承思路基本与 Java 相同，一定要仔细看例子并与 Java 代码对比，一定可以理解的 w 接口 接口定义关键字：interface，格式如下 123interface 接口名{ ...} 接口的实现，格式如下 1234class 类名 ： 接口名{ // 重写的接口函数、属性等 ...} 请看示例 1234567891011121314interface Person{ // 使用 interface 定义接口 fun name()}class Student : Person { // 使用: 来实现接口, 类似于 Java 的 implements 关键字 override fun name() { // 实现方法 println(&quot; 我的名字是 Suemor&quot;) }}fun main() { val student:Student = Student() // 实例化 Student student.name() // 调用实现的 name 方法} 123456789101112131415// 对应的 Java 代码interface Person { public void name();}class Student implements Person{ @Override public void name() { System.out.println(&quot; 我的名字是 Suemor&quot;); } public static void main(String[] args) { Student student = new Student(); student.name(); }} 最终输出 我的名字是 Suemor 使用 interface 定义接口 使用 : 来实现接口, 类似于 Java 的 implements 关键字","link":"/2021/08/20/Kotlin%E5%AD%A6%E4%B9%A0-2/"},{"title":"自我介绍","text":"正如域名所示我是常州刘国钧高等职业技术学校 计算机专业 的一名废材技校生，这是一所江苏境内的五年制高职。正因为自己初中学习不够努力成绩一直处于平均水平以及热爱推广职业教育的常州 40% 多中考录取率，直到最后也没有什么彻底醒悟成绩突飞猛进只有知乎上才能看到的剧情，因此中考考了一个很平均的分数从而很不幸的进入了这一所奇怪的技校，现在即将升入三年级，也就是同龄人的高三。 我的人格是 INTJ ，是一个 十分内向 的人。当得知中考成绩后我释然了，心中毫无波动，但我知道自己的人生完蛋了。我这里中考也没有什么复读的说法，只能无奈的进入了这一所学校。学校的管理措施相比于其他技校似乎更加严格，但依旧无法挽回身边奇怪的同学智力低下的事实。 我可以肯定身边的同学根本不是来学计算机的。经历了一个学期的计算机基础的学习，我们班级较早开始了 C 语言 的课程，可是奇怪的同学依旧连计算机最基础的操作都不会，怎么可能完成编程语言的学习呢？以至于我亲眼看到我的同桌到期中考试连”Hello World”都写不出来，我无奈的笑了。 因为是技校，身边大多数人素质普遍比较低，因此 校园欺凌 是不可避免的。在班上我总能看到弱势的同学遭到强势学生过分的需求，以至于哭泣，甚至有些时候强势的学生当着部分老师的面实施欺凌，老师却能视而不见，悠哉的掏出他的手机，刷着某音，直到上课。正如同前文所说，我是一个十分内向的人，可能代码写的比其他人要好，有时候校园欺凌也会在我的头上发生，但是远不及上文同学的多，我都默默承受了。 emm 可能扯远了吧，技校的奇怪还有很多超乎你想象的，不过我不想再过多举例，下面来聊聊我自己。 “事务对我们都会有影响，其价值必须定量，而非定性地讨论。出去义务扫马路可以陶冶你的情操，还可以锻炼身体。坐在家里背单词背一天你可以学会数百个新单词，提升英语水平。按照上提到的“善意的逻辑”，这两者各有好处，仿佛难以取舍。但是我想在实际操作中，不会有人认为前者对你的益处更大。 说道理大家都清楚，但是在实际生活中，我们却总能见到某些组织的头目派手下同学站在食堂门口发传单，以“锻炼大家的社会实践能力”。我们也能见到不少同学东一榔头西一棒槌地学了许多与自己职业规划毫无关系的课程，美其名曰“扩充知识面”。 在打着各种华丽口号的诱惑面前，我们要保持清醒，并且时刻告诫自己 总有更值得做的事。” 我无法理解奇怪人的脑回路，因此我现在已经离开了班级和宿舍并加入了学校智能家居的集训队，因为是 全国职业院校技能大赛 因此难度十分低，与参加 noi 的 OIer 们完全没法比，可偏偏技校的比赛基本都是 团队型项目，也就代表着我要和奇怪的人一同比赛，我陷入了沉思。。 最后再说说自己的学习情况和对未来的展望吧~其实自己真正开始学习编程是从高职二年级开始的，因为受到了社交平台人们的启发（这个以后再聊），让我认知有很大提升，才开始踏入正轨。 现在已经过去一年了，我逐渐按时间学习了 C, Java, MySQL, SpringBoot, Android 等技术的基础（关于技术的话题以后会经常写的，本文就不展开了），现在正在学习 Android,Kotlin, C++, qt，在接下来的一年内我首先要应对技能比赛（希望队友能给点力 w），然后去学习自己薄弱的英语，多背单词和看英文文章，参加五年级的专转本考试（希望能考上个南京二本学校吧），再去学点高数并在闲暇时间看看C++ Primer, CS:APP 和它对应的 15-213 课程 然后完成相应 lab，计算机网络等书，再学学前端 Vue 等技术，有空再做算法题， 再学学 Rust?，可能的话尝试去 github 参加些开源项目。。 补充 上海交通大学生存手册 邮箱: 3100825062@qq.com","link":"/2021/08/17/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"}],"tags":[{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"}],"categories":[{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"}]}